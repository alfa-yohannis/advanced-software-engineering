\chapter{Sistem yang Berjalan}

\section*{Tujuan Pembelajaran}
\begin{itemize}
  \item Menjalankan sebuah sistem perangkat lunak yang telah dikonfigurasi dan
        menyiapkan lingkungan runtime yang diperlukan tanpa pengetahuan awal
        mengenai desain internal sistem tersebut.
  \item Memodifikasi parameter konfigurasi serta mengamati, mendeskripsikan, dan
        menafsirkan perilaku runtime yang dihasilkan, termasuk kondisi operasi
        normal maupun skenario kegagalan.
  \item Menalar sistem perangkat lunak berdasarkan eksekusi yang diamati dan
        mengenali keterbatasan pemahaman yang hanya berbasis perilaku sebagai
        motivasi untuk memperkenalkan konsep desain dan pemodelan pada tahap
        berikutnya.
\end{itemize}

\section{Pendahuluan}

Bab ini memperkenalkan sistem perangkat lunak dari sudut pandang
\emph{eksekusi sebelum abstraksi}. Alih-alih memulai dengan diagram arsitektur,
model, atau konsep desain formal, sebuah sistem perangkat lunak nyata yang
sedang berjalan diperkenalkan sebagai objek kajian utama. Sistem ini dapat
dijalankan, dikonfigurasi, dan diamati secara langsung. Gagasan inti dari bab
ini adalah bahwa pemahaman yang bermakna terhadap sistem perangkat lunak perlu
berakar pada perilaku runtime yang konkret sebelum penalaran pada tingkat desain
diperkenalkan.

Melalui interaksi awal dengan sistem yang berjalan, intuisi dibangun mengenai
bagaimana perangkat lunak bereaksi terhadap perubahan konfigurasi, kondisi
lingkungan, serta skenario kegagalan. Pendekatan ini secara sengaja menunda
penggunaan terminologi arsitektur dan konstruksi pemodelan, sehingga model mental
mahasiswa berkembang melalui observasi, eksperimen, dan penalaran sebab–akibat.

Bab ini dirancang untuk mengakomodasi peserta dengan latar belakang pendidikan
yang beragam. Bagi peserta non-IT, penekanan diberikan pada menjalankan sistem,
mengubah parameter, serta mendeskripsikan perilaku yang diamati menggunakan
bahasa alami. Bagi peserta dengan latar belakang IT, penekanan diberikan pada
eksekusi container, konfigurasi lingkungan, dan diagnosis runtime. Seluruh
aktivitas dilakukan menggunakan sistem yang sama, sehingga memungkinkan
perbandingan observasi pada berbagai tingkat keterlibatan teknis.

Bab ini membangun fondasi pengalaman yang akan digunakan pada bab-bab berikutnya,
di mana perilaku runtime yang telah diamati secara bertahap diabstraksikan
menjadi struktur arsitektur, model formal, dan prinsip desain.

\section{Alasan Memulai dari Sistem yang Berjalan}

Pendidikan rekayasa perangkat lunak secara tradisional sering dimulai dari
artefak desain seperti dokumen kebutuhan, diagram arsitektur, atau notasi
pemodelan. Meskipun abstraksi tersebut sangat penting untuk pengembangan sistem
berskala besar dan jangka panjang, pemaknaannya dapat menjadi sulit apabila
intuisi terhadap perilaku runtime belum terbentuk. Dalam kondisi seperti ini,
konsep desain berisiko diperlakukan sebagai representasi statis atau simbolik,
bukan sebagai deskripsi dari sistem yang benar-benar dieksekusi.

Memulai dari sistem yang berjalan membalik urutan tersebut. Alih-alih
mengandalkan perilaku yang dibayangkan dari diagram atau spesifikasi, sistem yang
dapat diamati dan dieksekusi diperkenalkan sebagai objek kajian utama. Sistem
dapat dijalankan, dikonfigurasi, dan diamati secara langsung, sehingga konsekuensi
dari perubahan konfigurasi dapat terlihat secara segera. Pengalaman konkret ini
menyediakan titik acuan yang kuat bagi seluruh abstraksi yang akan diperkenalkan
pada tahap selanjutnya.

Pendekatan yang berfokus pada perilaku juga mencerminkan kondisi yang umum
dijumpai dalam praktik rekayasa perangkat lunak. Interaksi dengan sistem yang
sudah ada sering kali terjadi tanpa dokumentasi desain yang lengkap atau mutakhir.
Pemahaman kemudian dibangun melalui observasi terhadap log, keluaran sistem,
karakteristik performa, dan mode kegagalan. Paparan awal terhadap pola penalaran
ini mendukung pengembangan kemampuan diagnosis dan analisis yang bersifat
praktis.

Bagi peserta tanpa latar belakang IT, interaksi awal dengan sistem yang berjalan
mengurangi hambatan masuk. Keterlibatan dimungkinkan melalui pengamatan perilaku,
identifikasi hubungan sebab–akibat, serta deskripsi respons sistem secara verbal,
tanpa memerlukan pemahaman sintaks pemrograman atau notasi pemodelan formal. Hal
ini mendukung pengembangan cara berpikir sistem tanpa bergantung pada kefasihan
teknis.

Bagi peserta dengan latar belakang IT, pendekatan yang sama justru menyingkap
keterbatasan penalaran yang berangkat dari desain semata. Sistem yang tampak benar
pada level desain dapat menunjukkan perilaku yang tidak terduga ketika
dideploy, salah dikonfigurasi, atau dijalankan dalam kondisi lingkungan yang
berbeda. Pengalaman awal dengan perbedaan tersebut menekankan pentingnya konteks
runtime, manajemen konfigurasi, dan penalaran operasional.

Secara keseluruhan, memulai dari sistem yang berjalan membangun landasan
pengalaman bersama bagi peserta dengan latar belakang yang beragam. Pendekatan
ini membumikan konsep teoretis pada perilaku yang dapat diamati dan mempersiapkan
transisi konseptual dari eksekusi konkret menuju desain formal dan pemodelan pada
bab-bab berikutnya.

\section{Gambaran Umum Sistem Perangkat Lunak Contoh}

Sistem perangkat lunak contoh yang digunakan dalam bab ini merupakan sebuah
pipeline runtime terdistribusi berskala kecil yang terdiri dari beberapa node
yang saling bekerja sama. Setiap node dijalankan sebagai proses independen dan
berkomunikasi dengan node lain pada saat runtime. Sistem ini dirancang secara
sengaja agar mudah diamati, mudah dikonfigurasi, dan mudah dijalankan, namun tetap
mewakili sistem perangkat lunak multi-komponen yang realistis.

\begin{figure}[htbp]
\centering
\scalebox{1.1}{
\begin{tikzpicture}[
  font=\small\bfseries,
  node distance=9mm and 12mm,
  box/.style={
    draw,
    rounded corners=2mm,
    align=center,
    minimum width=32mm,
    minimum height=9mm,
    fill=blue!10
  },
  brokerbox/.style={box,fill=orange!15},
  webbox/.style={box,fill=green!12},
  browserbox/.style={box,fill=gray!12},
  arrow/.style={-Latex,thick}
]

\node[brokerbox] (broker) {Broker\\(XSUB / XPUB)};
\node[box,left=of broker,yshift=+9mm] (capturer) {Capturer\\(Node A)};
\node[box,right=of broker,yshift=+9mm] (transformer) {Transformer\\(Node B)};

\node[webbox,below=of broker,xshift=+28mm] (web) {Web Server\\(Node C)};
\node[browserbox,below=of broker,xshift=-28mm] (browser) {Browser};

\draw[arrow] (capturer) -- node[above,xshift=2mm]{PUB \texttt{raw}} (broker);
\draw[arrow] (broker) -- node[above,xshift=-2mm]{SUB \texttt{raw}} (transformer);
\draw[arrow] (transformer.south) |- node[below]{PUB \texttt{processed}} (broker.east);
\draw[arrow] (broker.south) -- node[right,xshift=3mm]{SUB \texttt{processed}} (web.north);
\draw[arrow] (web.west) -- node[above]{HTTP MJPEG} (browser.east);

\end{tikzpicture}
}
\caption{Data flow architecture using broker-based publish--subscribe communication}
\label{fig:broker-pubsub-architecture}
\end{figure}


Seperti ditunjukkan pada Gambar~\ref{fig:broker-pubsub-architecture}, sistem ini
terdiri atas empat node utama:

\begin{itemize}
  \item \textbf{Broker:} Berfungsi sebagai perantara pesan antara seluruh node
        lainnya. Node ini tidak menghasilkan maupun mengonsumsi data aplikasi,
        melainkan merutekan pesan antara publisher dan subscriber menggunakan
        mekanisme publish–subscribe. Peran ini memungkinkan keterlepasan
        (loose coupling) antar komponen serta memungkinkan setiap node untuk
        dijalankan, dihentikan, atau digantikan secara independen.
  \item \textbf{Capturer (Node-A):} Berfungsi sebagai sumber data sistem. Frame
        dibaca dari masukan video dan dipublikasikan secara periodik sebagai pesan.
        Setiap pesan memuat data citra beserta metadata seperti timestamp dan
        identitas frame.
  \item \textbf{Transformer (Node-B):} Berlangganan data yang dihasilkan oleh
        Node-A dan menerapkan langkah pemrosesan sebelum mempublikasikan ulang
        hasilnya. Pada sistem contoh, pemrosesan ini berupa transformasi citra,
        seperti konversi ke grayscale.
  \item \textbf{Web Server (Node-C):} Berlangganan data yang telah diproses dan
        menyajikan keluaran melalui antarmuka web. Citra hasil pemrosesan
        disiarkan secara real time, sehingga perilaku runtime sistem dapat diamati
        langsung melalui peramban.
\end{itemize}

Komunikasi antar node diimplementasikan menggunakan pola pesan publish–subscribe.
Data mengalir dari capturer ke broker dan selanjutnya ke transformer melalui topik
\texttt{raw}. Data yang telah diproses kemudian dirutekan kembali melalui broker
ke web server menggunakan topik \texttt{processed}. Setiap node bereaksi secara
mandiri terhadap pesan yang diterima, dan perilaku keseluruhan sistem muncul dari
interaksi runtime, bukan dari kontrol terpusat.

Eksekusi sistem dikelola menggunakan container, sehingga setiap node beroperasi
dalam lingkungan terisolasi dengan konfigurasi masing-masing. Perilaku sistem
dikendalikan melalui environment variable, termasuk endpoint koneksi, laju
publikasi, dan parameter pemrosesan. Perubahan parameter tersebut mengubah
perilaku runtime yang dapat diamati tanpa memerlukan perubahan pada kode sumber.

Struktur berbasis node ini memungkinkan pengamatan terhadap bagaimana data
bergerak di dalam sistem yang berjalan, bagaimana komponen saling berinteraksi
dan bergantung satu sama lain pada saat runtime, serta bagaimana pilihan
konfigurasi dan urutan eksekusi memengaruhi perilaku keseluruhan sistem.
Pengamatan ini dilakukan tanpa memperkenalkan diagram arsitektur atau konsep
pemodelan pada tahap ini, sehingga fokus tetap pada eksekusi konkret dan efek
yang dapat diamati.


\section{Perangkat dan Lingkungan Eksekusi}
\subsection{Perangkat Lunak dan Platform yang Diperlukan}

Untuk memungkinkan eksekusi sistem perangkat lunak contoh secara andal dengan
upaya penyiapan yang minimal, bab ini menggunakan sejumlah kecil alat yang
digunakan secara luas dan didukung dengan baik. Alat-alat ini menyediakan
lingkungan eksekusi yang konsisten pada berbagai sistem operasi dan mengurangi
pengaruh perbedaan platform terhadap perilaku runtime.

Platform eksekusi utama yang digunakan adalah teknologi container, khususnya
Docker. Docker memungkinkan sistem contoh dikemas bersama seluruh dependensi yang
dibutuhkan dan dijalankan secara seragam pada berbagai mesin. Melalui
containerization, sistem yang sama dapat dijalankan pada Windows, macOS, maupun
Linux tanpa memerlukan konfigurasi sistem tingkat rendah yang rumit.

Selain Docker, Python digunakan sebagai bahasa implementasi untuk masing-masing
node sistem. Python dipilih karena keterbacaannya, tingkat adopsinya yang luas,
serta ekosistem pustaka pendukung yang kaya. Pada tahap ini, pemahaman penuh
terhadap detail implementasi tidak diperlukan; namun penggunaan Python
menyediakan lingkungan eksekusi yang familier untuk analisis dan eksperimen pada
tahap selanjutnya.

Untuk skenario eksekusi tanpa container, lingkungan virtual Python diperkenalkan
untuk mengelola dependensi. Lingkungan virtual memungkinkan setiap proyek
memiliki kumpulan paket Python yang terisolasi, sehingga mencegah interferensi
antar proyek atau dengan instalasi sistem secara global. Mekanisme ini
memperkuat konsep isolasi lingkungan, yang paralel dengan isolasi yang disediakan
oleh container.

Editor kode atau lingkungan pengembangan terintegrasi juga diperlukan untuk
mendukung interaksi dengan sistem. Visual Studio Code direkomendasikan karena
ketersediaannya lintas platform, ekosistem ekstensi yang luas, serta dukungan
bawaan untuk alur kerja Python dan Docker. Dalam bab ini, editor terutama
digunakan untuk mengedit berkas konfigurasi, memeriksa log, dan mengeksekusi
perintah, bukan untuk pengembangan kode secara intensif.

Secara kolektif, alat-alat ini membentuk lingkungan eksekusi yang minimal namun
lengkap. Docker menyediakan isolasi dan reprodusibilitas, Python menyediakan
runtime sistem contoh, lingkungan virtual mendukung eksperimen lokal, dan editor
memfasilitasi interaksi serta observasi. Dengan demikian, aktivitas dalam bab ini
tetap berfokus pada eksekusi runtime dan perilaku yang dapat diamati, bukan pada
permasalahan penyiapan platform.

\subsection{Peran Containerization}

Containerization memainkan peran sentral dengan memungkinkan interaksi terhadap
sebuah sistem perangkat lunak lengkap yang sedang berjalan tanpa memerlukan
pemahaman awal mengenai struktur internal atau detail implementasinya. Dengan
mengemas setiap node sistem beserta pustaka dan dependensi runtime yang
dibutuhkan, container menyediakan lingkungan eksekusi yang dapat diprediksi dan
direproduksi pada berbagai mesin dan sistem operasi.

Dalam bab ini, container digunakan sebagai mekanisme utama untuk mengeksekusi
masing-masing node pada sistem contoh. Setiap node—yaitu broker, Node~A
(capturer), Node~B (transformer), dan Node~C (web server)—dijalankan sebagai proses
independen di dalam container tersendiri. Pemisahan ini memungkinkan pengamatan
terhadap operasi paralel dan interaksi runtime antar komponen tanpa pengelolaan
proses atau dependensi secara manual.

Containerization juga membuat konfigurasi menjadi eksplisit. Alih-alih
memodifikasi kode sumber, perilaku sistem diatur melalui environment variable
yang diberikan pada saat container dijalankan. Parameter seperti endpoint
koneksi, port jaringan, interval publikasi, dan opsi pemrosesan dapat diubah
tanpa membangun ulang image aplikasi. Model eksekusi ini menekankan bahwa
perilaku sistem yang diamati dipengaruhi tidak hanya oleh kode, tetapi juga oleh
konfigurasi dan lingkungan runtime.

Dari sudut pandang pembelajaran, container bertindak sebagai batas eksekusi yang
jelas. Dalam konteks non-IT, container dapat diperlakukan sebagai unit eksekusi
yang dapat dijalankan, dihentikan, dan dikonfigurasi, sehingga fokus tetap pada
perilaku sistem yang dapat diamati. Dalam konteks IT, containerization membuka
pembahasan mengenai isu runtime praktis seperti pembangunan image, jaringan
container, dan diagnosis pada saat eksekusi.

Akhirnya, containerization menyoroti perbedaan antara perspektif desain dan
runtime. Meskipun diagram arsitektur dan model formal sengaja tidak diperkenalkan
pada tahap ini, sistem yang berjalan tetap menunjukkan struktur implisit melalui
interaksi container dan pola komunikasi. Oleh karena itu, eksekusi berbasis
container menyediakan fondasi konkret bagi bab-bab berikutnya, di mana konsep
arsitektur, pertimbangan deployment, dan teknik pemodelan akan diperkenalkan
berdasarkan hasil observasi runtime sebelumnya.

\section{Instalasi dan Persiapan Lingkungan}
\label{sec:installation_and_environment_preparation}

\subsection{Instalasi Python dan Manajemen Versi}

Python diperlukan sebagai lingkungan runtime untuk mengeksekusi node-node
individual dalam sistem perangkat lunak contoh. Untuk memastikan perilaku yang
konsisten pada berbagai mesin, versi Python tertentu harus dipasang dan
diverifikasi sebelum aktivitas eksekusi dilakukan. Untuk bab ini, Python versi
3.12 direkomendasikan.

Subbagian ini memberikan panduan instalasi langkah demi langkah untuk dua
platform yang umum digunakan, yaitu Windows dan Ubuntu Linux.

\subsubsection{Instalasi Python pada Windows}

Pada sistem Windows, Python sebaiknya diinstal menggunakan installer resmi yang
disediakan oleh Python Software Foundation.

Proses instalasi meliputi langkah-langkah berikut:

\begin{itemize}
  \item Buka situs resmi Python di \texttt{https://www.python.org}.
  \item Unduh installer Windows untuk Python~3.12 (64-bit).
  \item Jalankan berkas installer.
  \item Aktifkan opsi \texttt{Add Python to PATH} sebelum memulai instalasi.
  \item Pilih opsi instalasi bawaan dan selesaikan proses instalasi.
\end{itemize}

Setelah instalasi selesai, verifikasi dilakukan dengan membuka Command Prompt dan
menjalankan perintah berikut:

\begin{lstlisting}[language=bash]
python --version
\end{lstlisting}

Keluaran perintah tersebut seharusnya menampilkan Python~3.12.x. Jika versi yang
ditampilkan berbeda atau perintah tidak dikenali, konfigurasi PATH pada sistem
perlu diperiksa kembali.


\subsubsection{Instalasi Python pada Ubuntu Linux}

Pada sistem Ubuntu, Python sering kali sudah terpasang secara bawaan. Namun,
versi yang tersedia belum tentu sesuai dengan versi yang dibutuhkan pada bab ini.
Karena itu, instalasi Python~3.12 direkomendasikan.

Prosedur instalasi meliputi langkah-langkah berikut:

\begin{itemize}
  \item Buka terminal.
  \item Perbarui indeks paket:
\end{itemize}

\begin{lstlisting}[language=bash]
sudo apt update
\end{lstlisting}

\begin{itemize}
  \item Instal Python~3.12 beserta alat pendukungnya:
\end{itemize}

\begin{lstlisting}[language=bash]
sudo apt install python3.12 python3.12-venv python3.12-dev
\end{lstlisting}

Setelah instalasi selesai, lakukan verifikasi dengan menjalankan:

\begin{lstlisting}[language=bash]
python3.12 --version
\end{lstlisting}

Keluaran perintah tersebut seharusnya mengonfirmasi bahwa Python~3.12.x telah
tersedia.

\subsubsection{Mengelola Banyak Versi Python}

Ketika beberapa versi Python hidup berdampingan pada satu sistem, pemanggilan
interpreter yang diinginkan harus dilakukan secara eksplisit. Di Windows, hal ini
dapat dilakukan dengan \texttt{python} atau \texttt{py -3.12}. Di Ubuntu, interpreter
sebaiknya dipanggil secara eksplisit sebagai \texttt{python3.12}.

Memastikan versi Python yang benar terinstal dan dapat diakses membangun fondasi
yang stabil untuk langkah-langkah berikutnya, termasuk pembuatan virtual
environment dan instalasi dependensi, yang akan diperkenalkan setelah ini.

\subsection{Membuat dan Menggunakan Virtual Environment}

Virtual environment menyediakan konteks eksekusi Python yang terisolasi, sehingga
dependensi dapat dipasang dan dikelola secara terpisah dari instalasi Python pada
tingkat sistem. Isolasi ini mencegah konflik versi antar proyek dan memastikan
bahwa eksperimen yang dilakukan tidak mengganggu perangkat lunak lain pada mesin
yang sama. Dalam konteks bab ini, virtual environment digunakan untuk eksekusi
lokal dan inspeksi sistem di luar container.

Sebuah virtual environment berupa direktori khusus yang berisi interpreter Python
serta repositori paket privat. Ketika environment aktif, seluruh perintah terkait
Python, termasuk instalasi paket dan eksekusi skrip, akan dibatasi pada direktori
ini.

\subsubsection{Tujuan Virtual Environment}

Penggunaan virtual environment memiliki beberapa tujuan dalam bab ini. Pertama,
mendukung reprodusibilitas dengan menetapkan himpunan pustaka yang terinstal
hanya pada yang dibutuhkan sistem contoh. Kedua, menyediakan konteks eksekusi
yang bersih untuk mengamati perilaku runtime tanpa interferensi dari proyek
sebelumnya atau paket global. Ketiga, memperkenalkan konsep isolasi eksekusi yang
sejalan (meski dalam skala lebih kecil) dengan isolasi yang disediakan container.

\subsubsection{Membuat Virtual Environment}

Sebelum membuat virtual environment, interpreter Python yang kompatibel harus
sudah terinstal dan dapat diakses, sebagaimana dijelaskan pada subbagian
sebelumnya. Virtual environment sebaiknya dibuat di direktori akar proyek agar
asosiasi antara environment dan codebase tetap jelas.

Pada Windows, virtual environment dapat dibuat dengan perintah berikut:

\begin{lstlisting}[language=bash]
python -m venv .venv
\end{lstlisting}

Pada Ubuntu Linux, disarankan memanggil versi Python yang dibutuhkan secara
eksplisit:

\begin{lstlisting}[language=bash]
python3.12 -m venv .venv
\end{lstlisting}

Eksekusi perintah tersebut akan membuat direktori bernama \texttt{.venv} yang
memuat runtime Python terisolasi, package manager, serta berkas konfigurasi
pendukung.

\subsubsection{Mengaktifkan Virtual Environment}

Setelah dibuat, virtual environment harus diaktifkan agar interpreter dan set
dependensi terisolasi dapat digunakan. Aktivasi akan memodifikasi environment
shell saat ini sehingga perintah Python dan manajemen paket mengarah ke virtual
environment, bukan ke instalasi sistem.

Pada Windows:

\begin{lstlisting}[language=bash]
.venv\Scripts\activate
\end{lstlisting}

Pada Ubuntu Linux:

\begin{lstlisting}[language=bash]
source .venv/bin/activate
\end{lstlisting}

Setelah aktif, prompt terminal biasanya menampilkan nama environment sebagai
penanda. Seluruh perintah berikutnya akan dieksekusi dalam konteks terisolasi ini.

\subsubsection{Menginstal Dependensi}

Saat virtual environment aktif, paket Python yang diperlukan dapat diinstal
secara lokal menggunakan package manager. Instalasi dependensi pada tahap ini
memastikan seluruh pustaka yang dibutuhkan tersedia tanpa mengubah environment
Python pada tingkat sistem.

\begin{lstlisting}[language=bash]
pip install --upgrade pip
pip install pyzmq pillow bottle waitress opencv-python-headless
\end{lstlisting}

Paket-paket tersebut akan tetap terkurung di dalam virtual environment dan hanya
dapat diakses ketika environment aktif.

\subsubsection{Menggunakan Virtual Environment untuk Eksekusi}

Ketika menjalankan skrip Python yang terkait dengan sistem contoh, virtual
environment harus tetap dalam keadaan aktif. Hal ini memastikan interpreter dan
versi pustaka yang digunakan sesuai. Eksekusi dari dalam virtual environment
pada dasarnya mencerminkan perilaku yang diamati saat menjalankan sistem dalam
container, dengan perbedaan utama yaitu tidak adanya isolasi sistem operasi
secara penuh.

\subsubsection{Menonaktifkan Virtual Environment}

Setelah eksekusi lokal atau eksperimen selesai, virtual environment dapat
dinonaktifkan untuk mengembalikan shell ke kondisi semula.

\begin{lstlisting}[language=bash]
deactivate
\end{lstlisting}

\subsubsection{Keterkaitan dengan Eksekusi Berbasis Container}

Virtual environment menyediakan mekanisme ringan untuk isolasi dependensi dan
eksperimen lokal. Meskipun tidak sekomprehensif isolasi berbasis container,
virtual environment menegaskan prinsip yang sama: perilaku runtime ditentukan
oleh kombinasi terkontrol antara kode, dependensi, dan konfigurasi. Prinsip ini
akan kembali ditekankan pada bagian berikutnya ketika eksekusi dilakukan
menggunakan container.

\subsection{Instalasi dan Konfigurasi Visual Studio Code}

Visual Studio Code digunakan sebagai lingkungan utama untuk berinteraksi dengan
sistem perangkat lunak contoh. Perannya dibatasi pada pengeditan berkas
konfigurasi, inspeksi log, navigasi berkas proyek, dan eksekusi perintah. Aktivitas
pengembangan kode secara mendalam atau debugging sengaja ditunda ke bab-bab
selanjutnya.

Visual Studio Code dipilih karena tersedia lintas platform, ringan, dan memiliki
dukungan kuat untuk Python, Docker, dan alur kerja berbasis terminal.

\subsubsection{Instalasi Visual Studio Code}

Visual Studio Code sebaiknya diinstal melalui distribusi resmi yang disediakan
oleh Microsoft.

Pada semua platform, instalasi dimulai dengan mengunjungi situs resmi berikut:

\texttt{https://code.visualstudio.com}

\paragraph{Instalasi pada Windows}

Pada Windows, instalasi dilakukan sebagai berikut:

\begin{itemize}
  \item Unduh installer Windows dari situs resmi.
  \item Jalankan berkas installer.
  \item Aktifkan opsi untuk menambahkan Visual Studio Code ke PATH dan
        mendaftarkannya sebagai editor untuk tipe berkas yang didukung.
  \item Selesaikan instalasi menggunakan pengaturan bawaan.
\end{itemize}

Setelah terinstal, Visual Studio Code dapat dijalankan melalui Start Menu atau
melalui command line dengan:

\begin{lstlisting}[language=bash]
code
\end{lstlisting}

\paragraph{Instalasi pada Ubuntu Linux}

Pada Ubuntu, Visual Studio Code dapat diinstal menggunakan repository paket resmi.
Jalankan perintah berikut di terminal:

\begin{lstlisting}[language=bash]
sudo apt update
sudo apt install code
\end{lstlisting}

Setelah terinstal, editor dapat dijalankan dari menu aplikasi atau langsung dari
terminal:

\begin{lstlisting}[language=bash]
code
\end{lstlisting}

\subsubsection{Konfigurasi Awal}

Setelah instalasi, hanya diperlukan konfigurasi minimal. Fokusnya adalah
memastikan akses terminal dan dukungan bahasa dasar, bukan kustomisasi tingkat
lanjut.

Hal-hal berikut sebaiknya dipastikan tersedia:

\begin{itemize}
  \item Akses integrated terminal
  \item Tampilan file explorer
  \item Dukungan untuk membuka folder yang berisi berkas proyek
\end{itemize}

Integrated terminal digunakan untuk menjalankan perintah Python, mengaktifkan
virtual environment, dan menjalankan perintah terkait container. Terminal ini
dapat dibuka melalui menu atau menggunakan pintasan keyboard yang disediakan
editor.

\subsubsection{Ekstensi yang Direkomendasikan}

Meskipun opsional, pemasangan beberapa ekstensi berikut akan mempermudah
interaksi dengan lingkungan eksekusi:

\begin{itemize}
  \item \textbf{Python}: Menyediakan syntax highlighting dan dukungan bahasa dasar
        untuk berkas Python.
  \item \textbf{Docker}: Memungkinkan inspeksi container yang sedang berjalan,
        image, dan log langsung dari antarmuka editor.
\end{itemize}

Ekstensi dapat diinstal melalui marketplace ekstensi bawaan pada editor.

\subsubsection{Peran Editor}

Visual Studio Code berfungsi sebagai antarmuka ringan untuk mengamati dan
berinteraksi dengan sistem yang berjalan. Editor digunakan untuk melihat struktur
proyek, memodifikasi berkas konfigurasi, memeriksa keluaran runtime, serta
mengeksekusi perintah dalam lingkungan yang terkontrol. Penggunaan editor ini
mendukung fokus pada eksekusi dan observasi, bukan pada detail desain atau
implementasi, selaras dengan penekanan bab ini: menjalankan sistem sebelum desain
formal.

\subsection{Instalasi Docker dan Docker Compose}

Docker digunakan sebagai platform utama untuk mengeksekusi sistem perangkat lunak
contoh secara konsisten dan dapat direproduksi. Melalui containerization, seluruh
komponen sistem dapat dijalankan beserta dependensi yang diperlukan, sehingga
perbedaan sistem operasi host menjadi kurang berpengaruh. Docker Compose digunakan
untuk mengoordinasikan eksekusi beberapa container yang bersama-sama membentuk
sistem runtime.

\subsubsection{Instalasi Docker pada Windows}

Pada Windows, Docker diinstal melalui Docker Desktop, yang menyediakan lingkungan
terintegrasi untuk eksekusi container.

Proses instalasi meliputi langkah-langkah berikut:

\begin{itemize}
  \item Kunjungi situs resmi Docker di \texttt{https://www.docker.com}.
  \item Unduh Docker Desktop untuk Windows.
  \item Jalankan installer dan ikuti instruksi pada layar.
  \item Aktifkan fitur virtualisasi yang diperlukan jika diminta.
\end{itemize}

Setelah instalasi, Docker Desktop harus dijalankan dan dibiarkan menyelesaikan
setup awal. Verifikasi instalasi dapat dilakukan dengan membuka Command Prompt
atau PowerShell dan menjalankan:

\begin{lstlisting}[language=bash]
docker --version
docker compose version
\end{lstlisting}

Keberhasilan eksekusi perintah tersebut mengonfirmasi bahwa Docker dan Docker
Compose telah tersedia.

\subsubsection{Instalasi Docker pada Ubuntu Linux}

Pada Ubuntu, Docker dapat diinstal menggunakan repository paket Docker. Jalankan
perintah berikut di terminal:

\begin{lstlisting}[language=bash]
sudo apt update
sudo apt install docker.io docker-compose-plugin
\end{lstlisting}

Setelah instalasi, layanan Docker perlu dijalankan dan diaktifkan:

\begin{lstlisting}[language=bash]
sudo systemctl enable docker
sudo systemctl start docker
\end{lstlisting}

Verifikasi instalasi dapat dilakukan dengan menjalankan:

\begin{lstlisting}[language=bash]
docker --version
docker compose version
\end{lstlisting}

\subsubsection{Mengelola Izin Docker}

Pada Ubuntu, perintah Docker secara bawaan memerlukan hak akses elevated
(\texttt{sudo}). Agar Docker dapat digunakan tanpa awalan \texttt{sudo}, pengguna
aktif dapat ditambahkan ke grup \texttt{docker}:

\begin{lstlisting}[language=bash]
sudo usermod -aG docker $USER
\end{lstlisting}

Setelah perintah tersebut dijalankan, pengguna perlu logout dan login kembali
agar perubahan izin berlaku.


\subsubsection{Peran Docker Compose}

Docker Compose digunakan untuk mendefinisikan dan menjalankan sistem contoh
multi-container sebagai satu kesatuan. Setiap node pada sistem didefinisikan
sebagai sebuah \emph{service} di dalam berkas konfigurasi Compose, termasuk
\emph{image} yang digunakan, environment variable, konfigurasi jaringan, serta
ketergantungan urutan startup.

Dengan Docker Compose, seluruh sistem dapat dijalankan, dihentikan, dan
dikonfigurasi ulang menggunakan sedikit perintah. Pendekatan ini menekankan
komposisi dan konfigurasi pada level runtime, bukan pengelolaan container secara
manual. Hal ini juga selaras dengan fokus bab ini: memahami perilaku sistem
melalui eksekusi dan observasi, bukan melalui artefak desain.

\section{Alur Pengembangan dan Eksekusi}

Bagian ini menjelaskan alur pengembangan dan eksekusi yang digunakan pada bab
ini, yang bergerak dari eksekusi langsung pada level kode menuju orkestrasi
sistem berbasis container yang sepenuhnya otomatis. Urutan ini merefleksikan
transisi bertahap dari kontrol manual ke eksekusi yang reprodusibel dan mudah
diskalakan, sekaligus menyoroti tantangan praktis yang muncul pada tiap tahap
(Gambar~\ref{fig:development-execution-flow}).

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
  font=\small,
  node distance=8mm,
  box/.style={
    draw,
    rounded corners=2mm,
    align=center,
    minimum width=60mm,
    minimum height=8mm
  },
  arrow/.style={-Latex, thick}
]

\node[box] (code) {Pengembangan dengan Kode Python\\(Broker, Node A, Node B, Node C)};
\node[box, below=of code] (manual) {Eksekusi Manual\\Banyak Terminal, Urutan Eksplisit};
\node[box, below=of manual] (config) {Konfigurasi Dieksternalisasi\\Environment Variable / File / Skrip Bash};
\node[box, below=of config] (docker) {Container Docker\\Lingkungan Runtime Konsisten};
\node[box, below=of docker] (compose) {Docker Compose\\Eksekusi Multi-Node Otomatis};

\draw[arrow] (code) -- node[right]{} (manual);
\draw[arrow] (manual) -- node[right]{eksekusi manual} (config);
\draw[arrow] (config) -- node[right]{masalah dependensi} (docker);
\draw[arrow] (docker) -- node[right]{eksekusi manual} (compose);

\end{tikzpicture}
\caption{Alur pengembangan dan eksekusi dari level kode hingga orkestrasi container}
\label{fig:development-execution-flow}
\end{figure}

\subsection{Membangun Node Sistem Menggunakan Python}

Pengembangan dimulai pada level kode, di mana setiap node sistem diimplementasikan
sebagai program Python yang berdiri sendiri. Skrip terpisah dibuat untuk broker,
Node~A (capturer), Node~B (transformer), dan Node~C (web server). Pada tahap ini,
endpoint komunikasi, port, dan parameter eksekusi umumnya masih ditanam langsung
di dalam kode atau diberikan melalui argumen command line.

Fase ini menetapkan kebenaran fungsional pada level komponen individual. Setiap
node dapat dijalankan secara mandiri, dan perilaku runtime dasar dapat
diverifikasi secara terisolasi.

\subsection{Eksekusi Manual Program Python}

Setelah implementasi selesai, sistem dijalankan dengan cara memulai setiap proses
Python secara manual melalui command line. Node dijalankan dalam urutan tertentu
agar endpoint komunikasi sudah tersedia ketika dibutuhkan. Environment variable
atau parameter command line digunakan untuk mengatur koneksi dan perilaku eksekusi.

Meskipun pendekatan ini memberi kontrol dan transparansi yang tinggi, kompleksitas
operasional ikut meningkat. Diperlukan banyak terminal, urutan startup harus
dikelola secara eksplisit, dan eksekusi menjadi lebih rentan error seiring
bertambahnya jumlah komponen.

\subsection{Memusatkan Konfigurasi untuk Eksekusi yang Lebih Otomatis}

Untuk mengurangi beban manual, nilai konfigurasi seperti port, topik, dan alamat
host dieksternalisasi ke berkas konfigurasi atau definisi environment variable.
Dengan begitu, node dapat dijalankan lebih konsisten dan tidak perlu mengubah kode
setiap kali parameter runtime disesuaikan.

Namun, pendekatan ini memunculkan tantangan baru ketika eksekusi dipindahkan ke
mesin lain. Perbedaan sistem operasi, pustaka yang terpasang, dan lingkungan
runtime dapat menyebabkan perilaku yang tidak konsisten, meskipun berkas
konfigurasi tidak berubah.

\subsection{Membungkus Node dalam Container untuk Konsistensi Eksekusi}

Untuk mengatasi ketidakkonsistenan lingkungan, setiap node dikemas ke dalam
container Docker. \emph{Image} container mengenkapsulasi kode aplikasi beserta
seluruh dependensi yang dibutuhkan, sehingga perilaku eksekusi lebih konsisten
lintas mesin.

Pada tahap ini, container biasanya masih dibangun dan dijalankan secara manual.
Walaupun konsistensi lingkungan telah tercapai, konfigurasi dan proses startup
tetap memerlukan perintah eksplisit untuk tiap container. Urutan eksekusi,
konfigurasi jaringan, dan environment variable masih harus dikelola manual,
sehingga skalabilitas dan kemudahan penggunaan masih terbatas.

\subsection{Orkestrasi Sistem Menggunakan Docker Compose}

Docker Compose diperkenalkan untuk mengotomatisasi eksekusi seluruh sistem.
Setiap node didefinisikan sebagai service dalam satu berkas konfigurasi, termasuk
image, environment variable, port yang diekspos, serta dependensi terhadap service
lain.

Dengan Docker Compose, sistem multi-node dapat dijalankan, dihentikan, dan
dikonfigurasi ulang menggunakan sedikit perintah. Pendekatan ini menghilangkan
kebutuhan mengatur urutan startup secara manual, menyederhanakan manajemen
konfigurasi, dan memastikan eksekusi yang konsisten lintas mesin. Karena itu,
Docker Compose menjadi puncak alur pengembangan pada bab ini, menyediakan model
eksekusi yang reprodusibel sekaligus efisien secara operasional.

\section{Eksekusi Awal Sistem}
\subsection{Menjalankan Container yang Sudah Disediakan}
\label{sec:initial_system_execution}

Sebelum menjalankan sistem, kode sumber perlu diperoleh secara lokal. Implementasi
lengkap dari sistem perangkat lunak contoh tersedia publik pada repositori berikut:

\noindent\url{https://github.com/alfa-yohannis/advanced-software-engineering}

Kode sumber dapat diperoleh melalui antarmuka grafis maupun melalui command line.

Melalui peramban, repositori dapat diunduh sebagai arsip terkompresi dengan
menekan tombol \texttt{Code} pada halaman repositori dan memilih opsi
\texttt{Download ZIP} dari tab \texttt{Local}. Setelah unduhan selesai, arsip
perlu diekstrak ke direktori kerja lokal.

Alternatifnya, repositori dapat di-\emph{clone} menggunakan Git. Dari terminal,
jalankan perintah berikut untuk mengambil seluruh isi repositori:

\begin{lstlisting}[language=bash]
git clone https://github.com/alfa-yohannis/advanced-software-engineering.git
\end{lstlisting}

Setelah diunduh atau di-\emph{clone}, struktur direktori proyek perlu diperiksa.
Materi yang digunakan untuk eksekusi awal sistem berada pada path berikut di dalam
repositori:

\texttt{advanced-software-engineering/projects/session-01/python/}

Seluruh perintah pada subbagian ini harus dijalankan dari direktori tersebut,
karena di situlah tersimpan kode sumber Python, definisi container, dan berkas
konfigurasi yang dibutuhkan untuk menjalankan sistem.

Pada tahap ini, eksekusi menggunakan image container yang sudah disediakan
(\emph{prebuilt}) alih-alih memanggil skrip Python satu per satu secara manual.
Mode eksekusi ini mengasumsikan bahwa Docker dan Docker Compose sudah terpasang
dan terkonfigurasi sebagaimana dijelaskan pada
Bagian~\ref{sec:installation_and_environment_preparation}.

Untuk menjalankan sistem menggunakan konfigurasi container yang tersedia, masuk
ke direktori proyek lalu jalankan perintah berikut:

\begin{lstlisting}[language=bash]
cd advanced-software-engineering/projects/session-01/python
docker compose up
\end{lstlisting}

Perintah ini akan menyalakan seluruh komponen yang dibutuhkan, termasuk broker,
Node~A (capturer), Node~B (transformer), dan Node~C (web server), sesuai definisi
di berkas Compose. Setup jaringan, environment variable, dan urutan startup
container ditangani secara otomatis.

Selama eksekusi, log runtime dari seluruh container akan ditampilkan ke terminal,
sehingga aktivitas sistem dapat diamati secara langsung. Setelah startup selesai,
sistem mulai memproses data dan menghasilkan keluaran yang dapat diamati tanpa
memerlukan koordinasi manual.

Menjalankan sistem menggunakan container yang sudah disediakan membentuk baseline
yang konsisten untuk mengamati perilaku runtime. Manajemen dependensi lokal dan
orkestrasi proses diabstraksikan, sehingga fokus tetap pada eksekusi, interaksi
antar komponen, dan keluaran sistem yang tampak, bukan pada kompleksitas setup.

\subsection{Memverifikasi Keberhasilan Eksekusi}

Setelah sistem dijalankan menggunakan Docker Compose, keberhasilan eksekusi perlu
diverifikasi sebelum melanjutkan ke aktivitas berikutnya. Verifikasi difokuskan
pada tiga hal: memastikan seluruh container berjalan, komunikasi antar node
terjalin, dan keluaran yang dapat diamati muncul sebagaimana diharapkan.

\subsubsection{Memeriksa Status Container}

Langkah verifikasi pertama adalah memeriksa apakah seluruh container yang
dibutuhkan sedang berjalan. Dari direktori proyek, jalankan perintah berikut:

\begin{lstlisting}[language=bash]
docker compose ps
\end{lstlisting}

Keluaran perintah seharusnya menampilkan seluruh service yang didefinisikan pada
Compose, termasuk broker, Node~A (capturer), Node~B (transformer), dan Node~C (web
server), dengan status \texttt{running}. Jika ada container yang berstatus
\texttt{exited} atau \texttt{restarting}, hal itu mengindikasikan masalah startup
atau konfigurasi yang harus diselesaikan sebelum melanjutkan.

\subsubsection{Memeriksa Log Runtime}

Log runtime memberikan informasi langsung tentang perilaku tiap komponen sistem.
Log dari seluruh container akan tampil otomatis ketika sistem dijalankan dengan
\texttt{docker compose up}. Jika sistem dijalankan dalam mode \emph{detached},
log dapat diperiksa dengan:

\begin{lstlisting}[language=bash]
docker compose logs
\end{lstlisting}

Keluaran log seharusnya menunjukkan bahwa tiap node berhasil berjalan dan
membangun koneksi ke broker. Pesan yang menandakan keberhasilan binding atau
koneksi ke endpoint komunikasi mengonfirmasi bahwa komunikasi antar node aktif.

\subsubsection{Mengamati Keluaran Melalui Web}

Keberhasilan eksekusi juga dapat diverifikasi melalui antarmuka web yang
disediakan oleh Node~C (web server). Setelah container berjalan, buka peramban dan
akses alamat berikut:

\url{http://localhost:8000}

Peramban seharusnya menampilkan tampilan langsung dari keluaran hasil pemrosesan
sistem. Keberadaan stream visual yang terus diperbarui mengonfirmasi bahwa data
ditangkap oleh Node~A, diproses oleh Node~B, dan dikirim ke web server melalui
broker.

Jika halaman web berhasil terbuka tetapi tidak ada keluaran yang terlihat, log
runtime perlu ditinjau untuk memastikan data benar-benar mengalir melalui semua
node dan tidak ada kesalahan konfigurasi.

\subsubsection{Mengonfirmasi Aliran Data Ujung-ke-Ujung}

Verifikasi ujung-ke-ujung tercapai apabila seluruh kondisi berikut terpenuhi:

\begin{itemize}
  \item Seluruh container berjalan tanpa error.
  \item Log runtime menunjukkan startup yang sukses dan pertukaran pesan.
  \item Antarmuka web menampilkan keluaran yang terus diperbarui.
\end{itemize}

Jika kondisi tersebut terpenuhi, sistem dapat dianggap beroperasi sebagai pipeline
runtime yang utuh. Pada titik ini, sistem dinyatakan berhasil dieksekusi dan siap
untuk eksperimen lanjutan, perubahan konfigurasi, atau pengamatan perilaku runtime.

\section{Aktivitas untuk Mahasiswa IT}

Bagian ini mendefinisikan aktivitas praktik yang berfokus pada eksekusi langsung,
konfigurasi runtime, dan penalaran operasional pada level proses dan container.
Penekanan diberikan pada eksekusi manual menggunakan Python, modifikasi parameter
kualitas pemrosesan secara terkontrol, serta penskalaan lapisan web serving untuk
menangani banyak klien secara bersamaan.

\subsection{Eksekusi Python Mentah}

\subsubsection{Aktivitas 1: Eksekusi Manual Menggunakan Proses Python}

Sistem dijalankan dengan mengeksekusi setiap node sebagai proses Python terpisah.
Aktivitas ini membutuhkan beberapa terminal dan pengaturan urutan startup secara
eksplisit.

\textbf{Langkah 1: Buka Direktori Proyek}

Eksekusi dilakukan dari direktori proyek:

\texttt{advanced-software-engineering/projects/session-01/python/}

\textbf{Langkah 2: Buat dan Aktifkan Virtual Environment}

Pada Ubuntu:

\begin{lstlisting}[language=bash]
source .venv/bin/activate
\end{lstlisting}

Pada Windows (PowerShell):

\begin{lstlisting}[language=bash]
.venv\Scripts\activate
\end{lstlisting}

\textbf{Langkah 3: Instal Dependensi}

\begin{lstlisting}[language=bash]
pip install --upgrade pip
pip install pyzmq pillow bottle waitress opencv-python-headless
\end{lstlisting}

\textbf{Langkah 4: Jalankan Node di Terminal Terpisah}

Buka 4 terminal. Terminal 1 (Broker):

\begin{lstlisting}[language=bash]
python broker.py
\end{lstlisting}

Terminal 2 (Capturer / Node-A):

\begin{lstlisting}[language=bash]
BROKER_HOST=127.0.0.1 PUB_PORT=5555 TOPIC=raw VIDEO_PATH=input.mp4 PUBLISH_EVERY_SEC=0.1 JPEG_QUALITY=80 LOOP=true python capturer.py
\end{lstlisting}

Terminal 3 (Transformer / Node-B):

\begin{lstlisting}[language=bash]
BROKER_HOST=127.0.0.1 SUB_PORT=5556 PUB_PORT=5555 SUB_TOPIC=raw PUB_TOPIC=processed JPEG_QUALITY_OUT=85 python transformer.py
\end{lstlisting}

Terminal 4 (Web Server / Node-C):

\begin{lstlisting}[language=bash]
BROKER_HOST=127.0.0.1 SUB_PORT=5556 SUB_TOPIC=processed HTTP_HOST=0.0.0.0 HTTP_PORT=8000 HTTP_THREADS=8 python web_server.py
\end{lstlisting}

Eksekusi dinyatakan berhasil jika peramban menampilkan keluaran pada:

\texttt{http://localhost:8000}

\subsubsection{Aktivitas 2: Mengubah Kualitas Keluaran Transformer}

Aktivitas ini mengubah kualitas JPEG keluaran dari transformer (Node-B) dan
mengamati dampaknya terhadap kejernihan visual, kebutuhan bandwidth, serta
performa runtime.

\textbf{Langkah 1: Identifikasi Parameter Kualitas}

Transformer menggunakan sebuah environment variable (atau parameter runtime) untuk
mengendalikan kualitas JPEG keluaran. Parameter yang diasumsikan digunakan adalah:

\texttt{JPEG\_QUALITY\_OUT}

\textbf{Langkah 2: Jalankan Beberapa Pengaturan Kualitas}

Jalankan ulang Node-B dengan nilai kualitas yang berbeda, lalu amati perbedaannya.

Kualitas rendah (bandwidth lebih kecil, artefak lebih banyak):

\begin{lstlisting}[language=bash]
BROKER_HOST=127.0.0.1 SUB_PORT=5556 PUB_PORT=5555 SUB_TOPIC=raw PUB_TOPIC=processed JPEG_QUALITY_OUT=40 python transformer.py
\end{lstlisting}

Kualitas tinggi (bandwidth lebih besar, artefak lebih sedikit):

\begin{lstlisting}[language=bash]
BROKER_HOST=127.0.0.1 SUB_PORT=5556 PUB_PORT=5555 SUB_TOPIC=raw PUB_TOPIC=processed JPEG_QUALITY_OUT=95 python transformer.py
\end{lstlisting}

Target pengamatan meliputi:
\begin{itemize}
  \item Artefak visual yang terlihat pada keluaran di browser.
  \item Perubahan responsivitas (kelancaran pengiriman frame).
  \item Indikator laju pemrosesan (misalnya FPS) pada log, jika tersedia.
\end{itemize}

\subsubsection{Aktivitas 3: Menskalakan Lapisan Web Server Menjadi Dua Instans}

Lapisan web server dapat diskalakan melalui eksekusi Python mentah dengan
menjalankan program yang sama lebih dari satu kali menggunakan konfigurasi port
HTTP yang berbeda. Setiap instans berlangganan stream data \texttt{processed} yang
sama, tetapi menyediakan layanan pada port yang berbeda.

\textbf{Jalankan Instans Web Server Pertama}

Di sebuah terminal, jalankan:

\begin{lstlisting}[language=bash]
BROKER_HOST=127.0.0.1 \
SUB_PORT=5556 \
SUB_TOPIC=processed \
HTTP_HOST=0.0.0.0 \
HTTP_PORT=8000 \
python web_server.py
\end{lstlisting}

Akses layanan pada:

\texttt{http://localhost:8000}

\textbf{Jalankan Instans Web Server Kedua}

Di terminal terpisah, jalankan:

\begin{lstlisting}[language=bash]
BROKER_HOST=127.0.0.1 \
SUB_PORT=5556 \
SUB_TOPIC=processed \
HTTP_HOST=0.0.0.0 \
HTTP_PORT=8001 \
python web_server.py
\end{lstlisting}

Akses layanan pada:

\texttt{http://localhost:8001}

Kedua instans web server berjalan secara bersamaan, menerima data hasil pemrosesan
yang sama, dan melayani permintaan secara independen melalui port yang berbeda.

\subsection{Menggunakan Perintah Docker}

Bagian ini menunjukkan bagaimana sistem dapat dijalankan dan dimodifikasi
menggunakan perintah Docker secara langsung tanpa bergantung pada Docker Compose.
Setiap node dijalankan secara eksplisit, sehingga manajemen siklus hidup container
dan konfigurasi menjadi terlihat dengan jelas.

\subsubsection{Aktivitas 1: Menjalankan Seluruh Node}

Pada aktivitas ini, seluruh node sistem dijalankan secara manual sebagai container
Docker terpisah. Container saling terhubung melalui jaringan default Docker, dan
setiap node dikonfigurasi menggunakan environment variable.

\textbf{Jalankan Broker}

\begin{lstlisting}[language=bash]
docker run --rm \
  --name broker \
  -p 5555:5555 -p 5556:5556 \
  broker
\end{lstlisting}

\textbf{Jalankan Capturer (Node A)}

\begin{lstlisting}[language=bash]
docker run --rm \
  --name capturer \
  -e BROKER_HOST=broker \
  -e PUB_PORT=5555 \
  capturer
\end{lstlisting}

\textbf{Jalankan Transformer (Node B)}

\begin{lstlisting}[language=bash]
docker run --rm \
  --name transformer \
  -e BROKER_HOST=broker \
  -e SUB_PORT=5556 \
  -e PUB_PORT=5555 \
  -e SUB_TOPIC=raw \
  -e PUB_TOPIC=processed \
  -e JPEG_QUALITY_OUT=85 \
  transformer
\end{lstlisting}

\textbf{Jalankan Web Server (Node C)}

\begin{lstlisting}[language=bash]
docker run --rm \
  --name web \
  -p 8000:8000 \
  -e BROKER_HOST=broker \
  -e SUB_PORT=5556 \
  -e SUB_TOPIC=processed \
  -e HTTP_HOST=0.0.0.0 \
  -e HTTP_PORT=8000 \
  web_server
\end{lstlisting}

Keluaran sistem dapat diamati pada \url{http://localhost:8000}.

\subsubsection{Aktivitas 2: Mengubah Kualitas Keluaran Transformer}

Aktivitas ini mengubah kualitas keluaran transformer dengan mengatur tingkat
kompresi JPEG. Container perlu dijalankan ulang dengan nilai environment variable
yang berbeda.

\textbf{Jalankan Transformer dengan Kualitas Lebih Rendah}

\begin{lstlisting}[language=bash]
docker run --rm \
  --name transformer \
  -e BROKER_HOST=broker \
  -e SUB_PORT=5556 \
  -e PUB_PORT=5555 \
  -e SUB_TOPIC=raw \
  -e PUB_TOPIC=processed \
  -e JPEG_QUALITY_OUT=40 \
  transformer
\end{lstlisting}

\textbf{Jalankan Transformer dengan Kualitas Lebih Tinggi}

\begin{lstlisting}[language=bash]
docker run --rm \
  --name transformer \
  -e BROKER_HOST=broker \
  -e SUB_PORT=5556 \
  -e PUB_PORT=5555 \
  -e SUB_TOPIC=raw \
  -e PUB_TOPIC=processed \
  -e JPEG_QUALITY_OUT=95 \
  transformer
\end{lstlisting}

Perubahan kualitas visual dan responsivitas dapat diamati melalui antarmuka web.

\subsubsection{Aktivitas 3: Menskalakan Lapisan Web Server Menjadi Dua Instans}

Dua container web server dapat dijalankan secara manual sebagai dua instans
terpisah. Setiap instans berlangganan stream \texttt{processed} yang sama dan
mengekspos port host yang berbeda.

Contoh: menjalankan dua instans dengan pemetaan port 8000 dan 8001.

\begin{lstlisting}[language=bash]
docker run --rm \
  -p 8000:8000 \
  -e BROKER_HOST=broker \
  -e SUB_PORT=5556 \
  -e SUB_TOPIC=processed \
  -e HTTP_HOST=0.0.0.0 \
  -e HTTP_PORT=8000 \
  web_server
\end{lstlisting}

\begin{lstlisting}[language=bash]
docker run --rm \
  -p 8001:8000 \
  -e BROKER_HOST=broker \
  -e SUB_PORT=5556 \
  -e SUB_TOPIC=processed \
  -e HTTP_HOST=0.0.0.0 \
  -e HTTP_PORT=8000 \
  web_server
\end{lstlisting}

Setiap container melayani secara independen di:
\url{http://localhost:8000} dan \url{http://localhost:8001}.

Pendekatan ini memungkinkan beberapa instans berjalan bersamaan, tetapi
membutuhkan manajemen container secara manual dan pengaturan port yang eksplisit.

\subsection{Cara Docker Compose}

Subbagian ini menunjukkan eksekusi dan modifikasi sistem menggunakan Docker
Compose. Berbeda dengan perintah Docker langsung, Docker Compose memusatkan
konfigurasi dalam satu berkas dan memungkinkan sistem multi-node dikelola secara
deklaratif.

\subsubsection{Aktivitas 1: Menjalankan Seluruh Node}

Seluruh node sistem didefinisikan sebagai service dalam berkas
\texttt{docker-compose.yml}. Contoh fragmen minimal yang menunjukkan strukturnya
ditampilkan berikut ini.

\begin{lstlisting}[language=bash]
services:
  broker:
    image: broker
    ports:
      - "5555:5555"
      - "5556:5556"

  capturer:
    image: capturer
    environment:
      - BROKER_HOST=broker
      - PUB_PORT=5555
    depends_on:
      - broker

  transformer:
    image: transformer
    environment:
      - BROKER_HOST=broker
      - SUB_PORT=5556
      - PUB_PORT=5555
      - SUB_TOPIC=raw
      - PUB_TOPIC=processed
      - JPEG_QUALITY_OUT=85
    depends_on:
      - broker

  web:
    image: web_server
    ports:
      - "8000:8000"
    environment:
      - BROKER_HOST=broker
      - SUB_PORT=5556
      - SUB_TOPIC=processed
      - HTTP_HOST=0.0.0.0
      - HTTP_PORT=8000
    depends_on:
      - broker
\end{lstlisting}

Sistem lengkap dapat dijalankan dengan:

\begin{lstlisting}[language=bash]
docker compose up
\end{lstlisting}

\subsubsection{Aktivitas 2: Mengubah Kualitas Keluaran Transformer}

Untuk mengubah kualitas keluaran transformer, yang diperlukan hanya perubahan
konfigurasi. Kode Python tidak perlu diubah.

Fragmen berikut menunjukkan environment variable yang relevan:

\begin{lstlisting}[language=bash]
transformer:
  image: transformer
  environment:
    - JPEG_QUALITY_OUT=40
\end{lstlisting}

Setelah nilai diubah, sistem dijalankan ulang:

\begin{lstlisting}[language=bash]
docker compose down
docker compose up
\end{lstlisting}

Perubahan kualitas visual dan perilaku runtime dapat diamati segera melalui
antarmuka web.

\subsubsection{Aktivitas 3: Menskalakan Lapisan Web Server Menjadi Dua Instans}

Untuk menjalankan dua instans web server, sebuah service tambahan dengan pemetaan
port yang berbeda dapat ditambahkan. Setiap service berlangganan stream data
\texttt{processed} yang sama.

\begin{lstlisting}[language=bash]
web1:
  image: web_server
  ports:
    - "8000:8000"
  environment:
    - BROKER_HOST=broker
    - SUB_PORT=5556
    - SUB_TOPIC=processed
    - HTTP_HOST=0.0.0.0
    - HTTP_PORT=8000
  depends_on:
    - broker

web2:
  image: web_server
  ports:
    - "8001:8000"
  environment:
    - BROKER_HOST=broker
    - SUB_PORT=5556
    - SUB_TOPIC=processed
    - HTTP_HOST=0.0.0.0
    - HTTP_PORT=8000
  depends_on:
    - broker
\end{lstlisting}

Setelah berkas Compose diperbarui, kedua instans dapat dijalankan dengan:

\begin{lstlisting}[language=bash]
docker compose up
\end{lstlisting}

Dua web server dapat diakses pada:

\begin{itemize}
  \item \url{http://localhost:8000}
  \item \url{http://localhost:8001}
\end{itemize}

Keduanya beroperasi secara independen, namun mengonsumsi stream data hasil
pemrosesan yang sama. Pendekatan ini menunjukkan bahwa Docker Compose
menyederhanakan replikasi dan konfigurasi dengan mengekspresikan struktur eksekusi
secara deklaratif, bukan melalui pengulangan perintah command line.

\subsection{Perbandingan: Docker CLI vs Docker Compose}

\emph{Scaling} manual menggunakan Docker CLI membutuhkan pengulangan perintah
secara eksplisit, pemetaan port secara manual, serta manajemen siklus hidup untuk
setiap instans container. Docker Compose memusatkan konfigurasi dan memungkinkan
orkestrasi multi-service serta scaling melalui sedikit perintah.

Untuk tujuan scaling yang sama (dua web server), Docker Compose memberikan alur
operasional yang lebih sederhana karena:

\begin{itemize}
  \item Konfigurasi terpusat dalam satu berkas.
  \item \emph{Service discovery} dan jaringan bersama yang berjalan otomatis.
  \item Kontrol siklus hidup dengan satu perintah (\texttt{up}, \texttt{down},
        \texttt{logs}, \texttt{ps}).
  \item Dukungan scaling bawaan untuk instans yang direplikasi.
\end{itemize}

Seluruh aktivitas ini memberi pengalaman konkret tentang eksekusi runtime secara
manual, kontrol kualitas berbasis parameter, serta replikasi service, sehingga
membangun fondasi operasional untuk topik berikutnya seperti topologi deployment,
runtime scaling, dan observabilitas sistem.

\section{Aktivitas untuk Mahasiswa Non-IT}

Bagian ini disusun sebagai aktivitas refleksi kolaboratif. Mahasiswa non-IT
bekerja dalam kelompok kecil dan diwajibkan berpasangan dengan setidaknya satu
mahasiswa yang memiliki latar belakang IT. Tujuan kolaborasi ini adalah
menggabungkan perspektif yang berbeda ketika mengamati dan menalar sistem
perangkat lunak yang sedang berjalan.

Aktivitas ini tidak menuntut mahasiswa non-IT untuk menulis kode atau memahami
detail implementasi teknis. Fokusnya adalah pada observasi bersama, diskusi, dan
penjelasan menggunakan bahasa yang jelas dan sehari-hari.

\subsection{Aktivitas Kelompok: Mengamati dan Menalar Sistem yang Berjalan}

Berdasarkan hasil pengamatan dan diskusi dalam kelompok campuran, jawablah lima
pertanyaan berikut. Pertanyaan-pertanyaan ini dirancang untuk mengarahkan refleksi
ke ide inti model-driven engineering, termasuk abstraksi, penyederhanaan,
otomasi, dan generasi.

\begin{enumerate}
  \item Variabel atau parameter apa yang sering berubah, dan bagian mana yang
        cenderung tetap serta dapat diulang lintas eksekusi?
  \item Aktivitas atau langkah apa yang berulang ketika menjalankan atau
        mengonfigurasi sistem?
  \item Apakah aktivitas berulang tersebut dapat diotomatisasi, dan apakah
        generasi kode atau konfigurasi dapat mengurangi usaha atau kesalahan saat
        pengembangan?
  \item Atribut apa yang paling penting dari sistem yang diperkenalkan (misalnya
        node, koneksi, parameter, atau urutan eksekusi)?
  \item Apakah merepresentasikan sistem dalam bentuk yang lebih familiar atau
        lebih tinggi level (misalnya berkas konfigurasi, DSL kecil, atau
        representasi visual) akan memudahkan fokus pada hal-hal yang penting?
\end{enumerate}

\section{Penutup}

Bab ini telah membangun fondasi pemahaman sistem perangkat lunak berbasis
\emph{behaviour-first} dengan menempatkan eksekusi sebagai objek kajian utama.
Sebuah pipeline runtime terdistribusi yang terdiri dari broker, capturer (Node A),
transformer (Node B), dan web server (Node C) telah dijalankan, dikonfigurasi,
dan diamati sebagai sebuah sistem yang benar-benar berjalan. Interaksi praktis
menegaskan bahwa perilaku yang tampak tidak hanya dibentuk oleh kode sumber,
melainkan juga oleh konfigurasi runtime, isolasi lingkungan, serta konteks
eksekusi, sebagaimana terlihat dari perbedaan antara eksekusi Python mentah,
perintah Docker langsung, dan orkestrasi Docker Compose.

Keterbatasan pemahaman yang hanya mengandalkan perilaku juga dibuat eksplisit.
Walaupun observasi membantu membangun intuisi tentang aliran data, dependensi,
dan efek kegagalan, pemahaman yang lengkap tidak dapat diturunkan semata-mata dari
hasil yang terlihat dan log. Keterbatasan ini memotivasi transisi menuju penalaran
pada level desain di bab-bab berikutnya, di mana perilaku runtime yang telah
diamati dapat dipetakan secara bertahap ke struktur arsitektur, model formal, dan
prinsip desain yang sistematis, sehingga sistem dapat dijelaskan dan diprediksi.
