\chapter{Kontrol Runtime, Keamanan, dan Kebijakan}

\section{Tujuan Pembelajaran}
\begin{itemize}
  \item Memahami bahwa \textbf{Security dalam DevSecOps bersifat berlapis}, tidak tunggal.
  \item Mengidentifikasi berbagai tingkat kontrol keamanan dari desain hingga runtime.
  \item Menjelaskan \textbf{posisi dan batasan} keamanan yang dibahas pada bab ini.
  \item Memahami keamanan runtime sebagai mekanisme pembatas perilaku sistem yang sedang berjalan.
\end{itemize}

\section{Pengantar Security dalam DevSecOps}

DevSecOps merupakan pendekatan pengembangan sistem yang mengintegrasikan \emph{development}, \emph{security}, dan \emph{operations} ke dalam satu siklus kerja yang berkesinambungan. Berbeda dengan paradigma tradisional yang memposisikan keamanan sebagai aktivitas terpisah di akhir pengembangan, DevSecOps menempatkan security sebagai bagian inheren dari seluruh siklus hidup sistem.

Pendekatan ini berangkat dari kesadaran bahwa sistem modern bersifat kompleks, terdistribusi, dan terus berubah. Dalam konteks tersebut, keamanan tidak dapat lagi diperlakukan sebagai \emph{gate} terakhir sebelum rilis, melainkan sebagai seperangkat kontrol yang hadir sejak desain hingga sistem berjalan di lingkungan produksi.

\subsection{DevSecOps sebagai Integrasi Development, Security, dan Operations}

Dalam DevSecOps, security tidak berdiri sebagai domain eksklusif satu tim atau satu peran tertentu. Praktik keamanan terdistribusi di antara pengembang yang menulis kode, operator yang mengelola lingkungan runtime, serta kebijakan organisasi yang mengatur bagaimana sistem boleh dan tidak boleh berperilaku.

Integrasi ini mengubah cara berpikir tentang keamanan. Alih-alih bertanya \emph{“apakah sistem ini sudah diuji keamanannya?”}, DevSecOps mendorong pertanyaan \emph{“kontrol keamanan apa saja yang aktif di setiap tahap siklus sistem?”}. Dengan demikian, security menjadi sifat emergen dari banyak keputusan kecil yang konsisten, bukan hasil dari satu aktivitas tunggal.

\subsection{Mengapa Security Tidak Bisa Dipusatkan di Satu Tahap}

Tidak ada satu tahap pun dalam siklus DevOps yang mampu menanggung seluruh beban keamanan sistem. Keputusan desain yang buruk tidak dapat sepenuhnya diperbaiki oleh enkripsi di runtime. Sebaliknya, implementasi yang rapi sekalipun dapat menjadi tidak aman jika konfigurasi deployment salah atau kebijakan operasional diabaikan.

Ancaman keamanan juga bersifat lintas tahap. Kesalahan desain menciptakan permukaan serangan konseptual, kesalahan implementasi menciptakan celah teknis, sementara kesalahan operasional membuka peluang eksploitasi di dunia nyata. Oleh karena itu, memusatkan security pada satu tahap menciptakan ilusi aman yang berbahaya.

DevSecOps menekankan bahwa setiap tahap hanya mampu mengurangi sebagian risiko, dan keamanan sistem secara keseluruhan bergantung pada akumulasi kontrol lintas tahap tersebut.

\subsection{Security sebagai Kontrol, bukan Sekadar Checklist}

Salah satu kesalahpahaman umum dalam praktik keamanan adalah memandang security sebagai daftar periksa (checklist): enkripsi ada atau tidak, autentikasi ada atau tidak, firewall aktif atau tidak. Pendekatan ini cenderung bersifat statis dan simbolik.

Dalam DevSecOps, security dipahami sebagai mekanisme kontrol terhadap perilaku sistem. Kontrol ini membatasi apa yang boleh dilakukan sistem, oleh siapa, dalam kondisi apa, dan pada tingkat mana. Dengan sudut pandang ini, keamanan tidak dinilai dari keberadaan fitur, melainkan dari perubahan perilaku sistem ketika kontrol diterapkan.

Bab ini menggunakan perspektif tersebut untuk membingkai diskusi keamanan. Fokus tidak diletakkan pada kelengkapan mekanisme keamanan, melainkan pada bagaimana satu kontrol runtime dapat mengubah risiko aktual sistem yang sedang berjalan, serta bagaimana kontrol tersebut diposisikan secara realistis dalam spektrum DevSecOps yang lebih luas.


\section{Tingkatan Security dalam DevSecOps}

Keamanan dalam DevSecOps tidak hadir sebagai satu mekanisme tunggal, melainkan sebagai lapisan kontrol yang tersebar di berbagai tahap siklus hidup sistem. Setiap tahap memiliki karakteristik risiko, jenis ancaman, serta bentuk kontrol keamanan yang berbeda. Oleh karena itu, keamanan sistem bersifat kumulatif, di mana setiap tahap berkontribusi mengurangi sebagian risiko.

\subsection{Security pada Tahap Desain}

Pada tahap desain, keamanan berfokus pada cara sistem dipahami dan dibatasi secara konseptual sebelum satu baris kode pun ditulis. Keputusan pada tahap ini bersifat fundamental dan menentukan ruang lingkup risiko sistem.

\emph{Contoh}, melalui kegiatan \emph{threat modeling}, perancang sistem mengidentifikasi aset penting, alur data kritis, serta potensi ancaman yang mungkin muncul dari aktor tidak berwenang. Dari analisis ini dapat ditentukan bagian sistem mana yang memerlukan kontrol tambahan pada tahap berikutnya.

\emph{Contoh lain}, penentuan \emph{trust boundary} digunakan untuk memisahkan komponen yang dipercaya dan tidak dipercaya. Misalnya, klien eksternal dan broker publik diperlakukan sebagai bagian yang tidak dipercaya, sehingga data yang melewati batas ini harus dianggap berisiko dan memerlukan perlindungan tambahan.

\subsection{Security pada Tahap Implementasi}

Tahap implementasi menerjemahkan keputusan desain ke dalam kode dan struktur program. Keamanan pada tahap ini berfokus pada pencegahan kesalahan teknis yang dapat dieksploitasi secara langsung.

\emph{Misalnya}, setiap input yang diterima dari luar sistem divalidasi dan disanitasi sebelum diproses lebih lanjut, untuk mencegah manipulasi data atau injeksi perintah berbahaya.

\emph{Selain itu}, pengembang memilih pustaka atau framework yang telah teruji dan dipelihara dengan baik, terutama untuk fungsi kriptografi dan komunikasi jaringan, daripada mengimplementasikan mekanisme keamanan sendiri yang berpotensi lemah.

\subsection{Security pada Tahap Build dan Artifact}

Pada tahap build, fokus keamanan bergeser ke artefak yang dihasilkan dari proses pengembangan. Risiko pada tahap ini sering kali berasal dari komponen pihak ketiga yang tidak terlihat secara langsung oleh pengembang.

\emph{Contoh}, proses build dapat mencakup pemeriksaan dependensi untuk mendeteksi pustaka yang memiliki kerentanan yang telah diketahui, sehingga artefak yang dihasilkan tidak membawa risiko tersembunyi ke lingkungan produksi.

\emph{Contoh lain}, praktik \emph{image hardening} pada container dilakukan dengan menghilangkan komponen yang tidak diperlukan, sehingga artefak yang dijalankan memiliki permukaan serangan yang lebih kecil.

\subsection{Security pada Tahap Deployment dan Environment}

Tahap deployment dan pengelolaan lingkungan menentukan bagaimana sistem dihadapkan pada kondisi operasional nyata. Kesalahan konfigurasi pada tahap ini dapat membatalkan kontrol keamanan yang telah dibangun sebelumnya.

\emph{Misalnya}, setiap layanan dijalankan dengan hak akses minimum yang diperlukan, sehingga kompromi satu komponen tidak secara otomatis memberikan kendali penuh terhadap sistem lain.

\emph{Selain itu}, rahasia seperti kunci enkripsi dan kredensial tidak disimpan di dalam kode aplikasi, melainkan dikelola melalui mekanisme konfigurasi runtime atau layanan pengelola rahasia di lingkungan deployment.

\subsection{Security pada Tahap Runtime dan Eksekusi}

Tahap runtime merupakan titik di mana sistem benar-benar berinteraksi dengan data, pengguna, dan lingkungan yang tidak sepenuhnya dapat diprediksi. Kontrol keamanan pada tahap ini bertujuan membatasi perilaku sistem yang sedang berjalan.

\emph{Contoh}, enkripsi payload diterapkan pada komunikasi antar komponen sehingga pihak yang tidak berwenang masih dapat mengamati lalu lintas data, tetapi tidak dapat membaca isi informasi yang dikirimkan.

\emph{Contoh lain}, komponen tertentu dibatasi hanya pada aksi yang diizinkan selama runtime, misalnya hanya dapat membaca data tanpa kemampuan memodifikasi atau menyebarkannya lebih lanjut.

Dengan melihat tingkatan ini secara berurutan, dapat dipahami bahwa keamanan dalam DevSecOps bukanlah hasil dari satu mekanisme tunggal, melainkan dari kombinasi kontrol yang saling melengkapi di berbagai tahap siklus sistem.


\section{Posisi Bab Ini dalam Spektrum DevSecOps}

Bab ini tidak bertujuan membahas keamanan sistem secara menyeluruh. Sejumlah aspek penting dalam DevSecOps---seperti analisis kerentanan statis, pengujian penetrasi, manajemen identitas dan akses, serta keamanan jaringan tingkat rendah---tidak dibahas secara mendalam. Topik-topik tersebut tetap penting, namun berada di luar ruang lingkup pembahasan bab ini.

Pembatasan fokus dilakukan karena keamanan dalam DevSecOps bersifat luas dan berlapis. Jika seluruh lapisan dibahas sekaligus dalam satu bab, pembahasan berisiko berubah menjadi daftar fitur tanpa pemahaman konseptual yang kuat. Karena itu, bab ini memilih satu contoh kontrol yang cukup spesifik agar pembaca dapat memahami logika keamanan sebagai kontrol yang bekerja pada sistem secara nyata.

Fokus bab ini diletakkan pada keamanan runtime, yakni kontrol yang aktif ketika sistem berjalan dan berinteraksi dengan lingkungan operasional. Keamanan runtime dipilih karena berada pada titik di mana risiko aktual muncul dan dampak kontrol dapat diamati langsung melalui perubahan perilaku sistem, bukan hanya melalui klaim desain atau asumsi implementasi.

Sebagai contoh, bab ini menggunakan enkripsi payload pada sistem terdistribusi untuk menunjukkan bagaimana kebijakan keamanan dapat diterjemahkan menjadi pembatasan keterbacaan data di runtime. Enkripsi dipilih karena jelas, terlokalisasi, dan mudah diverifikasi, sekaligus menegaskan batasannya: satu kontrol tidak otomatis membuat sistem aman. Pembaca diharapkan memahami posisi kontrol runtime dalam spektrum DevSecOps yang lebih luas, serta menyadari bahwa keamanan sistem merupakan hasil kombinasi kontrol lintas tahap, bukan satu mekanisme tunggal.



\section{Pengantar Kontrol Runtime}

Kontrol keamanan dalam sistem perangkat lunak dapat dibedakan berdasarkan kapan kontrol tersebut bekerja. Sebagian kontrol bersifat statis, diterapkan sebelum sistem dijalankan, sementara kontrol lainnya bersifat dinamis dan aktif ketika sistem sedang beroperasi. Perbedaan ini penting karena jenis risiko yang dihadapi sistem berubah secara signifikan ketika sistem berpindah dari tahap perancangan dan pembangunan ke tahap eksekusi nyata.

Kontrol statis, seperti analisis desain, pemeriksaan kode, atau validasi artefak build, berfungsi mencegah kelas kesalahan tertentu sebelum sistem digunakan. Kontrol ini bekerja berdasarkan asumsi dan skenario yang dapat diprediksi. Namun, ketika sistem telah berjalan, sistem berinteraksi dengan lingkungan, data, dan aktor yang tidak sepenuhnya dapat dikendalikan atau diperkirakan. Pada titik inilah kontrol statis mencapai batasnya.

Runtime menjadi sumber risiko nyata karena hampir seluruh dampak keamanan muncul saat sistem sedang beroperasi. Akses tidak sah, kebocoran data, penyalahgunaan layanan, dan eksfiltrasi informasi terjadi pada fase ini. Risiko tersebut tidak selalu berasal dari kesalahan desain atau implementasi, tetapi sering kali muncul dari cara sistem digunakan, disalahgunakan, atau dikombinasikan dengan kondisi lingkungan tertentu.

Kontrol runtime hadir untuk membatasi perilaku sistem yang sedang berjalan. Alih-alih hanya memastikan bahwa sistem dibangun dengan benar, kontrol ini mengatur apa yang boleh dan tidak boleh dilakukan sistem dalam kondisi operasional. Dengan demikian, fokus kontrol runtime bukan pada struktur sistem, melainkan pada aksi nyata yang dihasilkan selama eksekusi.

Sebagai mekanisme pembatas, kontrol runtime tidak menghilangkan semua risiko, tetapi mengurangi dampak ketika risiko tersebut terjadi. Misalnya, kontrol dapat memastikan bahwa data yang mengalir di jaringan tidak dapat dibaca oleh pihak yang tidak berwenang, atau bahwa suatu komponen tidak dapat melakukan aksi di luar perannya meskipun berhasil dijalankan.

Pendekatan ini menempatkan keamanan sebagai properti perilaku sistem, bukan sekadar atribut desain. Efektivitas kontrol runtime dapat diamati secara empiris melalui perubahan perilaku sistem, seperti perbedaan antara sistem sebelum dan sesudah kontrol diterapkan. Karakteristik inilah yang menjadikan kontrol runtime relevan untuk dikaji melalui eksperimen dan observasi, sebagaimana akan dibahas pada bagian-bagian selanjutnya dalam bab ini.


\section{Arsitektur Sistem Studi Kasus}

Arsitektur pada Gambar~\ref{fig:broker-pubsub-runtime-encryption} menggambarkan sebuah sistem terdistribusi berbasis komunikasi \emph{publish--subscribe} dengan broker sebagai perantara pertukaran pesan antar komponen. Pola ini dipilih karena merepresentasikan sistem terbuka dengan keterikatan longgar, di mana produsen dan konsumen data tidak saling mengenal secara langsung dan bergantung pada broker untuk distribusi pesan. Dalam arsitektur ini, \emph{Capturer} berperan sebagai penghasil data mentah, \emph{Transformer} sebagai pemroses data, dan \emph{Web Server} sebagai penyaji informasi kepada pengguna akhir, sementara broker bertindak sebagai komponen netral yang hanya meneruskan pesan berdasarkan topik.

\begin{figure}[htbp]
\centering
\scalebox{0.9}{
\begin{tikzpicture}[
  font=\small\bfseries,
  node distance=9mm and 12mm,
  box/.style={
    draw,
    rounded corners=2mm,
    align=center,
    minimum width=32mm,
    minimum height=9mm,
    fill=blue!10
  },
  brokerbox/.style={box,fill=orange!15},
  webbox/.style={box,fill=green!12},
  browserbox/.style={box,fill=gray!12},
  extbox/.style={box,fill=purple!10},
  annot/.style={font=\scriptsize\itshape, text=black!70},
  arrow/.style={-Latex,thick},
  dottedarrow/.style={-Latex,thick,dotted}
]

% Core nodes
\node[box] (transformer) {Transformer\\(Node B)\\{\scriptsize Prometheus service}};
\node[annot, above=1mm of transformer] {Decrypt $\rightarrow$ Process $\rightarrow$ Encrypt};

\node[box,left=of transformer, xshift=-10mm] (capturer) {Capturer\\(Node A)\\{\scriptsize Prometheus service}};
\node[annot, above=1mm of capturer] {Encrypt};

\node[brokerbox, below=of capturer, yshift=-5mm] (broker) {Broker\\(XSUB / XPUB)\\{\scriptsize Prometheus service}};

\node[browserbox,below=of broker] (browser) {Browser};

\node[webbox,right=of browser, xshift=10mm](web) {Web Server\\(Node C)\\{\scriptsize Prometheus service}};
\node[annot, below=1mm of web] {Decrypt};

% External observability nodes
\node[extbox,right=of web] (grafana) {Grafana};
\node[extbox,above=of grafana, yshift=10mm] (prom) {Prometheus};

% Data flow arrows (encrypted payload)
\draw[arrow] (capturer) -- 
  node[above, xshift=-8mm]{PUB \texttt{raw} (encrypted)} 
  (broker);

\draw[arrow] (broker) -- 
  node[above, yshift=-5mm, xshift=8mm]{SUB \texttt{raw} (encrypted)} 
  (transformer);

\draw[arrow] (transformer.south) |- 
  node[below]{PUB \texttt{processed} (encrypted)} 
  (broker.east);

\draw[arrow] (broker) -- 
  node[right,xshift=3mm]{SUB \texttt{processed} (encrypted)} 
  (web.north);

\draw[arrow] (web.west) -- 
  node[above]{HTTP MJPEG} 
  (browser.east);

% Observability
\draw[dottedarrow] (capturer.south) -- (prom);
\draw[dottedarrow] (broker) -- (prom);
\draw[dottedarrow] (transformer.east) -- (prom);
\draw[dottedarrow] (web.east) -- (prom);
\draw[arrow] (prom) -- (grafana);

\end{tikzpicture}
}
\caption{Arsitektur sistem publish--subscribe dengan enkripsi payload sebagai kontrol keamanan runtime, di mana proses enkripsi dan dekripsi dilakukan pada node produsen dan konsumen, sementara broker tetap tidak memiliki akses terhadap isi pesan}
\label{fig:broker-pubsub-runtime-encryption}
\end{figure}

Sebagai komponen infrastruktur, broker tidak memiliki kewenangan terhadap isi pesan yang ditransmisikan. Ia tidak memahami makna payload dan tidak dibekali kemampuan untuk memodifikasi atau menginterpretasikan data. Karakteristik ini menjadikan broker sebagai titik yang aman secara fungsional namun berisiko secara observasional, karena lalu lintas pesan yang melewatinya dapat diamati oleh pihak yang memiliki akses jaringan.

Untuk membatasi risiko tersebut, kontrol keamanan diterapkan pada tingkat runtime dalam bentuk enkripsi payload. Enkripsi tidak diperlakukan sebagai fitur tambahan aplikasi, melainkan sebagai mekanisme pembatas perilaku sistem yang sedang berjalan. Pada arsitektur ini, \emph{Capturer} mengenkripsi payload sebelum mempublikasikan pesan ke broker. \emph{Transformer} mendekripsi pesan yang diterima untuk diproses, kemudian mengenkripsi kembali hasil pemrosesan sebelum dipublikasikan ulang. \emph{Web Server} mendekripsi payload yang diterima sebelum menyajikan data ke browser. Sepanjang jalur komunikasi melalui broker, payload selalu berada dalam keadaan terenkripsi.

Dengan pendekatan ini, lalu lintas pesan tetap dapat diamati, tetapi isi informasi tidak dapat dibaca tanpa kunci yang sesuai. Kontrol yang diterapkan bukan membatasi alur data, melainkan membatasi keterbacaan dan pemaknaan data oleh pihak yang tidak berwenang. Hal ini menegaskan bahwa keamanan runtime berfokus pada perilaku sistem, bukan pada struktur arsitektur atau keberadaan fitur tertentu.

Kunci enkripsi dalam arsitektur ini merepresentasikan kebijakan keamanan runtime. Kepemilikan kunci menentukan siapa yang berhak mengakses makna data, terlepas dari siapa yang mampu mengamati pesan secara teknis. Sesuai dengan prinsip DevSecOps, kunci tidak ditanamkan secara statis di dalam kode atau diberikan kepada broker, melainkan dikelola sebagai rahasia operasional yang terpisah dari logika aplikasi.

Keputusan untuk tidak memberikan kunci enkripsi kepada broker bersifat konseptual dan operasional. Secara konseptual, broker diposisikan sebagai komponen yang tidak berwenang terhadap isi data. Secara operasional, keputusan ini membatasi dampak jika broker dikompromikan, karena payload yang dilewatkan tetap tidak dapat dibaca. Dengan demikian, keamanan sistem tidak bergantung pada kepercayaan terhadap satu komponen, melainkan pada pembatasan peran dan kebijakan yang diterapkan pada runtime.

Narasi ini menunjukkan bagaimana satu kontrol keamanan runtime yang sederhana dapat menurunkan risiko akses data pada sistem terdistribusi terbuka, tanpa mengubah arsitektur dasar sistem. Pendekatan ini menegaskan bahwa keamanan dalam DevSecOps bukanlah hasil dari satu mekanisme tunggal, melainkan dari kombinasi keputusan desain, implementasi, kebijakan, dan operasi yang membatasi perilaku sistem secara nyata.


\section{Eksperimen dan Validasi Kontrol Keamanan Runtime}

Eksperimen ini menunjukkan bahwa kontrol keamanan runtime dapat dibuktikan secara empiris melalui perubahan perilaku sistem yang sedang berjalan. Fokusnya bukan pada kriptografi sebagai teori, melainkan pada bagaimana satu kebijakan sederhana---enkripsi payload---membatasi keterbacaan data pada sistem terdistribusi berbasis publish--subscribe.

Skenario eksperimen terdiri dari tiga tahap. Pertama, sistem dijalankan tanpa kontrol keamanan sehingga payload yang melewati broker dapat dibaca sebagai data mentah. Kedua, kontrol enkripsi payload ditambahkan tanpa mengubah arsitektur dasar sistem, melainkan hanya mengubah perilaku endpoint: produsen mengenkripsi sebelum publish dan konsumen mendekripsi setelah subscribe. Ketiga, dilakukan simulasi akses oleh pihak tidak berwenang (sniffer) yang hanya mampu mengamati lalu lintas pesan, untuk menunjukkan perbedaan antara data yang terlihat dan data yang terbaca.

Titik observasi utama berada pada jalur komunikasi antar komponen, khususnya pada sisi broker/jaringan. Pada kondisi tanpa enkripsi, sniffer dapat menampilkan payload dalam bentuk yang bermakna (misalnya header dan bytes JPEG dapat dikenali). Pada kondisi terenkripsi, sniffer tetap dapat melihat adanya lalu lintas dan ukuran pesan, tetapi isi payload menjadi bytes acak yang tidak dapat ditafsirkan tanpa kunci. Dengan demikian, kontrol runtime yang diterapkan menghasilkan bukti perubahan perilaku sistem yang dapat diamati.

Kontrol enkripsi diimplementasikan menggunakan pustaka \texttt{cryptography} (Fernet). Kunci enkripsi diperlakukan sebagai rahasia runtime dan diinjeksi melalui konfigurasi environment pada container, bukan ditanamkan di dalam kode. Hal ini mencerminkan prinsip DevSecOps: pemisahan antara kode, konfigurasi, dan rahasia.

\subsection*{Generasi Kunci Enkripsi sebagai Kebijakan Runtime}

Sebelum kontrol enkripsi payload diterapkan pada sistem, diperlukan kunci enkripsi yang akan berfungsi sebagai kebijakan keamanan runtime. Kunci ini tidak dihasilkan oleh aplikasi saat berjalan, melainkan dibuat terlebih dahulu sebagai bagian dari proses persiapan operasional. Dengan pendekatan ini, kebijakan keamanan dipisahkan secara tegas dari logika aplikasi dan dapat dikelola secara independen.

Pada eksperimen ini, kunci enkripsi dihasilkan menggunakan pustaka \texttt{cryptography} dengan mekanisme Fernet. Proses generasi kunci dilakukan satu kali oleh operator atau administrator sistem, kemudian hasilnya didistribusikan ke komponen yang berwenang melalui konfigurasi runtime.

\begin{lstlisting}[style=PythonStyle, caption={Generate Fernet key for payload encryption}]
from cryptography.fernet import Fernet

key = Fernet.generate_key()
print(key.decode())
\end{lstlisting}

Output dari proses ini berupa string berbasis Base64 yang merepresentasikan kunci simetris. Nilai kunci tersebut kemudian digunakan sebagai nilai variabel lingkungan \texttt{PAYLOAD\_KEY} pada layanan yang memproduksi atau mengonsumsi payload terenkripsi.

Pemisahan tahap generasi kunci dari tahap eksekusi sistem menegaskan bahwa kunci enkripsi merupakan artefak kebijakan keamanan, bukan bagian dari implementasi aplikasi. Dengan demikian, rotasi kunci, penggantian kebijakan, atau pembatasan akses dapat dilakukan tanpa perubahan kode maupun arsitektur sistem.


\subsection*{Konfigurasi Kunci pada \texttt{docker-compose.yml}}

Contoh berikut menunjukkan bahwa setiap layanan yang perlu memproduksi atau mengonsumsi payload diberi variabel \texttt{PAYLOAD\_KEY}. Broker tidak diberi kunci, karena broker diposisikan sebagai komponen netral yang tidak berwenang membaca isi data.

\begin{lstlisting}[language=bash, caption={Inject PAYLOAD\_KEY via docker-compose environment}]
services:
  transformer:
    build:
      context: .
      dockerfile: transformer/Dockerfile
    environment:
      - PAYLOAD_KEY=RmTnzrS0_DwulCzF6tj8qSOQpCmnOkRmKeezZcZA4T4=
    # ...

  capturer:
    build:
      context: .
      dockerfile: capturer/Dockerfile
    environment:
      - PAYLOAD_KEY=RmTnzrS0_DwulCzF6tj8qSOQpCmnOkRmKeezZcZA4T4=
    # ...

  web:
    build:
      context: .
      dockerfile: web/Dockerfile
    environment:
      - PAYLOAD_KEY=RmTnzrS0_DwulCzF6tj8qSOQpCmnOkRmKeezZcZA4T4=
    # ...

  broker:
    image: zmq-broker:latest
    # intentionally no PAYLOAD_KEY here
\end{lstlisting}

\subsection*{Dependensi Python pada Dockerfile}

Berikut potongan Dockerfile yang menegaskan bahwa enkripsi adalah bagian dari runtime pipeline (bersama pyzmq, metrics, dll). Contoh ini merefleksikan kebutuhan node seperti capturer/transformer yang menggunakan OpenCV, observability, dan kontrol enkripsi.

\begin{lstlisting}[language=bash, caption={Install deps including cryptography in Dockerfile}]
# ---- python deps (capturer needs OpenCV + metrics + encryption)
RUN pip install --no-cache-dir \
    pyzmq \
    opencv-python-headless \
    prometheus-client \
    psutil \
    cryptography
\end{lstlisting}

\subsection*{Fungsi Enkripsi/Dekripsi (Shared Library)}

Agar konsisten lintas layanan, praktik yang umum adalah membuat modul bersama (misalnya \texttt{shared/crypto.py}) yang membaca \texttt{PAYLOAD\_KEY} dari environment dan menyediakan fungsi \texttt{encrypt\_bytes} serta \texttt{decrypt\_bytes}.

\begin{lstlisting}[style=PythonStyle, caption={Shared crypto helpers using PAYLOAD\_KEY}]
import os
from cryptography.fernet import Fernet

_PAYLOAD_KEY = os.environ["PAYLOAD_KEY"].encode()
_cipher = Fernet(_PAYLOAD_KEY)

def encrypt_bytes(data: bytes) -> bytes:
    return _cipher.encrypt(data)

def decrypt_bytes(token: bytes) -> bytes:
    return _cipher.decrypt(token)
\end{lstlisting}

\subsection*{Integrasi pada Transformer: Decrypt--Process--Encrypt}

Pada node \emph{Transformer}, pesan masuk dari broker berada dalam bentuk terenkripsi. Transformer mendekripsi header dan JPEG, memprosesnya, lalu mengenkripsi kembali output sebelum dipublikasikan. Potongan berikut menegaskan perubahan perilaku runtime yang menjadi inti eksperimen.

\begin{lstlisting}[style=PythonStyle, caption={Transformer decrypts input and encrypts output payload}]
# receive encrypted parts from broker
enc_header_b, enc_jpeg_in = recv_parts()

# decrypt at runtime
header_b = decrypt_bytes(enc_header_b)
jpeg_in  = decrypt_bytes(enc_jpeg_in)

# process (e.g., decode -> transform -> encode)
out_header_b, jpeg_out = process_frame(header_b, jpeg_in)

# encrypt again before publishing
t_encsec = time.time()
enc_out_header = encrypt_bytes(out_header_b)
enc_jpeg_out   = encrypt_bytes(jpeg_out)

send_parts(enc_out_header, enc_jpeg_out)
\end{lstlisting}

\subsection*{Kode Uji Lokal: Pastikan Enkripsi Berfungsi dan Kunci Valid}

Pengujian berikut memastikan dua hal: payload terenkripsi tidak sama dengan payload asli, dan dekripsi hanya berhasil jika kunci benar. Ini adalah uji minimum yang membantu mahasiswa melihat konsep \emph{data terlihat tetapi tidak terbaca}.

\begin{lstlisting}[style=PythonStyle, caption={Quick test: encrypt/decrypt roundtrip}]
import os
from cryptography.fernet import Fernet, InvalidToken

key = os.environ["PAYLOAD_KEY"].encode()
cipher = Fernet(key)

plain = b"header:frame=1;ts=123456"
token = cipher.encrypt(plain)

assert token != plain
assert cipher.decrypt(token) == plain

try:
    wrong = Fernet(Fernet.generate_key())
    wrong.decrypt(token)
    raise AssertionError("Should not decrypt with wrong key")
except InvalidToken:
    pass

print("OK: encryption on, wrong key fails, correct key succeeds.")
\end{lstlisting}

\subsection*{Validasi Observasional: Sniffer sebagai Representasi Ancaman}

Validasi keamanan dilakukan melalui observasi pasif menggunakan sniffer sebagai representasi ancaman. Sniffer diposisikan sebagai pihak yang dapat mengamati lalu lintas pesan (misalnya dari sisi jaringan), tetapi tidak memiliki kunci \texttt{PAYLOAD\_KEY}. Pada kondisi tanpa enkripsi, sniffer akan memperoleh bytes yang bermakna (misalnya header atau potongan JPEG yang dapat dikenali). Setelah enkripsi diterapkan, sniffer tetap melihat payload, namun yang terlihat hanyalah token terenkripsi yang tidak dapat ditafsirkan.

Contoh berikut menunjukkan cara mencetak sebagian bytes payload untuk menegaskan perbedaan \emph{terlihat} versus \emph{terbaca} tanpa melakukan eksploitasi apa pun.

\begin{lstlisting}[style=PythonStyle, caption={Sniffer view: visible bytes, unreadable without key}]
def hexdump(b: bytes, n: int = 32) -> str:
    return b[:n].hex()

# captured payload (e.g., from subscribed wire data)
captured = token  # in practice this comes from network capture
print("Visible (first bytes):", hexdump(captured))

# attacker has no key -> cannot decrypt (demonstrated by using wrong key)
from cryptography.fernet import InvalidToken
try:
    Fernet(Fernet.generate_key()).decrypt(captured)
except InvalidToken:
    print("Unreadable: decrypt failed without the correct key.")
\end{lstlisting}

Dengan rangkaian eksperimen ini, bukti perubahan perilaku runtime menjadi jelas: aliran data tetap terjadi, broker tetap berfungsi sebagai perantara, dan observabilitas sistem tetap berjalan, tetapi keterbacaan payload bagi pihak tidak berwenang dibatasi secara nyata. Hasil ini menegaskan bahwa kontrol keamanan runtime dapat diuji dan diverifikasi secara empiris melalui observasi, serta bahwa kunci enkripsi berperan sebagai kebijakan operasional yang menghubungkan DevSecOps dengan praktik operasi sehari-hari.



\section{Sudut Pandang Mahasiswa Non-IT}

\textbf{Apa risiko yang muncul ketika sebuah sistem tidak memiliki kontrol keamanan runtime?}  
Risiko utamanya adalah data dapat diakses, dibaca, atau disalahgunakan oleh pihak yang tidak berwenang tanpa disadari oleh pengguna maupun pengelola sistem. Sistem dapat tetap berfungsi secara normal dari sudut pandang pengguna, namun informasi yang mengalir di dalamnya berada dalam kondisi rentan. Ketika kontrol keamanan tidak hadir pada saat sistem berjalan, kepercayaan terhadap sistem sebenarnya bertumpu pada asumsi, bukan pada mekanisme perlindungan yang nyata.

\textbf{Bagaimana satu kontrol keamanan sederhana dapat menurunkan risiko tersebut?}  
Penerapan kontrol seperti enkripsi payload menunjukkan bahwa tidak semua upaya keamanan harus rumit untuk memberikan dampak berarti. Dengan enkripsi, data tetap mengalir dan sistem tetap beroperasi, tetapi makna informasi tidak lagi dapat diakses oleh pihak yang tidak memiliki izin. Kontrol ini secara langsung mengubah perilaku sistem pada runtime, dari sistem yang terbuka menjadi sistem yang membatasi keterbacaan data.

\textbf{Mengapa keamanan berkaitan dengan kepercayaan dan tanggung jawab?}  
Pengguna mempercayakan data mereka kepada sistem dengan harapan bahwa pengelola bertindak secara bertanggung jawab. Ketika kontrol keamanan diterapkan, pengelola sistem menunjukkan komitmen etis dan profesional dalam melindungi informasi pengguna. Keamanan, dalam konteks ini, bukan sekadar persoalan teknis, melainkan bagian dari hubungan kepercayaan antara sistem, pengelola, dan pengguna.

\section{Sudut Pandang Mahasiswa IT}

\textbf{Di mana posisi payload encryption dalam spektrum DevSecOps?}  
Enkripsi payload berada pada lapisan keamanan runtime dan eksekusi. Kontrol ini bekerja ketika sistem sedang berjalan dan berinteraksi dengan lingkungan nyata. Dalam spektrum DevSecOps, enkripsi runtime melengkapi kontrol keamanan pada tahap desain, implementasi, build, dan deployment, namun tidak menggantikannya. Memahami posisi ini membantu menghindari anggapan bahwa satu mekanisme keamanan sudah cukup untuk menjamin keseluruhan sistem.

\textbf{Apa keterbatasan kontrol keamanan yang diterapkan pada studi kasus ini?}  
Enkripsi payload hanya mengendalikan satu dimensi risiko, yaitu kerahasiaan data selama transmisi. Kontrol ini tidak mengatur siapa yang boleh mengakses sistem, tidak mencegah penyalahgunaan layanan, dan tidak melindungi sistem dari kesalahan logika atau konfigurasi. Selain itu, efektivitas enkripsi sangat bergantung pada pengelolaan kunci yang baik. Jika kunci bocor atau disalahkelola, kontrol ini kehilangan maknanya.

\textbf{Kontrol keamanan tambahan apa yang dapat diterapkan di tingkat lain?}  
Sebagai pengembangan, kontrol tambahan dapat diterapkan pada lapisan lain, seperti autentikasi dan otorisasi untuk mengatur akses, pembatasan hak istimewa pada runtime, atau validasi konfigurasi pada tahap deployment. Usulan ini menegaskan bahwa keamanan sistem yang matang selalu dibangun dari kombinasi kontrol yang saling melengkapi di berbagai tahap.

\section{Diskusi dan Refleksi}

\textbf{Apakah satu kontrol keamanan cukup untuk menyebut suatu sistem aman?}  
Satu kontrol keamanan jarang sekali cukup. Ia dapat mengurangi satu jenis risiko, tetapi tidak mampu mencakup seluruh ancaman yang mungkin muncul. Keamanan sistem bersifat bertingkat dan bergantung pada akumulasi keputusan di berbagai lapisan. Mengandalkan satu mekanisme berisiko menciptakan rasa aman semu.

\textbf{Apa risiko jika hanya fokus pada satu lapisan keamanan?}  
Fokus pada satu lapisan dapat membuat kelemahan pada lapisan lain terabaikan. Sistem yang terenkripsi dengan baik tetap dapat disalahgunakan jika tidak memiliki kontrol akses, pemantauan, atau kebijakan operasional yang memadai. Pendekatan berlapis diperlukan untuk mencegah kegagalan pada satu titik berdampak besar terhadap keseluruhan sistem.

\textbf{Bagaimana observabilitas membantu menilai efektivitas keamanan?}  
Observabilitas memungkinkan keamanan dievaluasi berdasarkan perilaku sistem yang nyata, bukan hanya berdasarkan klaim desain atau konfigurasi. Melalui observasi, perbedaan antara data yang terlihat dan data yang terbaca dapat dibuktikan secara empiris. Dengan demikian, observabilitas menjembatani keamanan sebagai konsep teoretis dengan keamanan sebagai praktik yang dapat diuji dan ditingkatkan secara berkelanjutan.



\section{Ringkasan}

Bab ini menegaskan bahwa security dalam DevSecOps bersifat berlapis dan tidak dapat dipusatkan pada satu tahap. Keamanan dipahami sebagai mekanisme kontrol terhadap perilaku sistem, bukan sekadar checklist fitur. Melalui spektrum kontrol dari desain hingga runtime, bab ini membatasi fokus pada keamanan runtime karena pada fase inilah risiko aktual muncul dan dampak kontrol dapat diamati secara langsung. Studi kasus sistem publish--subscribe menunjukkan broker sebagai komponen netral yang tidak berwenang, sehingga risiko kebocoran muncul pada jalur komunikasi dan endpoint. Enkripsi payload dipilih sebagai contoh kontrol runtime karena sifatnya jelas, terlokalisasi, dan mampu menunjukkan perbedaan antara data yang terlihat dan data yang terbaca.

Melalui eksperimen dan validasi observasional, ditunjukkan bahwa penerapan enkripsi payload mengubah perilaku runtime tanpa mengubah arsitektur dasar sistem: produsen mengenkripsi sebelum publish, konsumen mendekripsi setelah subscribe, sementara broker tetap tidak memiliki kunci. Kunci enkripsi diposisikan sebagai kebijakan runtime yang dikelola secara operasional melalui konfigurasi environment, mencerminkan pemisahan kode, konfigurasi, dan rahasia dalam DevSecOps. Refleksi untuk mahasiswa non-IT menekankan hubungan security dengan kepercayaan dan tanggung jawab, sedangkan untuk mahasiswa IT menegaskan keterbatasan satu kontrol dan pentingnya kontrol tambahan lintas tahap. Dengan dukungan observabilitas, efektivitas kontrol keamanan dapat dinilai secara empiris dan ditingkatkan secara berkelanjutan.

