\chapter{Integrasi dan Penerapan Berkelanjutan}


\section{Tujuan Pembelajaran}

Setelah mengikuti sesi ini, peserta diharapkan mampu:
\begin{itemize}
  \item menjelaskan konsep dan alur kerja \textit{Continuous Integration} dan \textit{Continuous Delivery/Deployment} (CI/CD) dalam pengembangan perangkat lunak modern;
  \item menerapkan workflow CI/CD berbasis GitHub Actions untuk melakukan pengujian otomatis dan deployment terkontrol pada aplikasi berbasis container;
  \item menganalisis integrasi antara pipeline CI/CD dan arsitektur sistem terdistribusi melalui studi kasus aplikasi \textit{text-to-speech} (TTS).
\end{itemize}


\section{Pendahuluan}

Dalam pengembangan perangkat lunak modern, perubahan kode tidak lagi terjadi secara sporadis dan individual, melainkan bersifat kontinu, kolaboratif, dan berlapis. Setiap commit dapat memengaruhi banyak komponen sekaligus, terutama pada sistem terdistribusi yang terdiri dari beberapa layanan independen. Kondisi ini menuntut adanya mekanisme yang mampu memastikan bahwa setiap perubahan tetap menjaga kualitas sistem secara keseluruhan tanpa mengorbankan kecepatan pengembangan.

Pendekatan \textit{Continuous Integration} dan \textit{Continuous Delivery/Deployment} (CI/CD) hadir sebagai jawaban atas tantangan tersebut. Dengan CI/CD, proses integrasi kode, pengujian, dan penyebaran aplikasi tidak lagi bergantung pada langkah manual yang rentan kesalahan, tetapi dijalankan secara otomatis dan konsisten melalui pipeline terdefinisi. Pipeline ini bertindak sebagai ``penjaga gerbang'' yang memverifikasi kualitas perubahan sebelum perubahan tersebut memengaruhi sistem yang berjalan.

Pada bab ini, konsep CI/CD tidak hanya dibahas secara teoritis, tetapi juga diterapkan pada sebuah studi kasus nyata berupa sistem \textit{text-to-speech} (TTS) berbasis layanan terdistribusi. Studi kasus ini dipilih karena mencerminkan karakteristik umum aplikasi modern: adanya API, layanan web, komponen pemrosesan asinkron, penyimpanan objek, serta gateway sebagai titik masuk pengguna. Melalui contoh ini, peserta diharapkan dapat melihat bagaimana pipeline CI/CD berinteraksi langsung dengan arsitektur aplikasi dan lingkungan runtime berbasis container.

Dengan mengaitkan konsep CI/CD, GitHub Actions, dan \texttt{docker-compose} dalam satu alur terpadu, bab ini bertujuan membangun pemahaman yang utuh mengenai bagaimana integrasi berkelanjutan dan penerapan berkelanjutan mendukung pengembangan sistem yang andal, dapat direproduksi, dan mudah dievolusikan. Pendekatan ini menjadi fondasi penting sebelum melangkah ke topik lanjutan seperti skalabilitas, observabilitas, dan otomasi infrastruktur.


\section{Apa yang Dimaksud dengan CI/CD?}

CI/CD merupakan singkatan dari \textit{Continuous Integration} dan
\textit{Continuous Delivery} (atau \textit{Continuous Deployment}), yaitu
sebuah pendekatan dalam rekayasa perangkat lunak yang bertujuan untuk
mengotomatisasi proses integrasi kode, pengujian, dan penyebaran aplikasi.
Pendekatan ini dirancang untuk mengurangi kesalahan manual, mempercepat siklus
pengembangan, serta meningkatkan keandalan sistem yang dikembangkan secara
kolaboratif.

\textit{Continuous Integration} (CI) mengacu pada praktik di mana setiap
perubahan kode yang dibuat oleh pengembang secara rutin diintegrasikan ke
repository pusat. Setiap integrasi akan secara otomatis memicu proses build
dan pengujian, sehingga kesalahan dapat terdeteksi lebih awal. Dengan CI,
masalah seperti konflik kode, dependensi yang rusak, atau kegagalan pengujian
tidak menumpuk dan dapat segera ditangani sebelum berkembang menjadi masalah
yang lebih kompleks.

\textit{Continuous Delivery} (CD) melanjutkan konsep CI dengan memastikan
bahwa hasil integrasi yang telah lolos pengujian selalu berada dalam kondisi
siap untuk dideploy. Dalam konteks ini, proses deployment telah dipersiapkan
dan divalidasi, tetapi keputusan untuk melakukan rilis ke lingkungan target
masih dapat dikontrol secara eksplisit. Variasi lanjutan dari pendekatan ini
adalah \textit{Continuous Deployment}, di mana setiap perubahan yang lolos CI
langsung dideploy secara otomatis tanpa intervensi manual.

Dalam praktik modern, CI/CD tidak hanya mencakup pengujian kode, tetapi juga
melibatkan build container, validasi konfigurasi infrastruktur, serta
pengujian integrasi end-to-end. Dengan demikian, CI/CD menjadi fondasi utama
bagi pengembangan sistem terdistribusi dan aplikasi berbasis microservices,
seperti studi kasus TTS yang digunakan pada modul ini.

\section{Workflow CI/CD}

Workflow CI/CD merepresentasikan urutan langkah terotomatisasi yang dijalankan
setiap kali terjadi perubahan pada kode sumber. Workflow ini biasanya
didefinisikan dalam bentuk berkas konfigurasi deklaratif (misalnya file YAML)
dan dijalankan oleh sistem otomasi seperti GitHub Actions.

Pada tahap awal workflow, perubahan kode yang di-\textit{push} ke repository
akan memicu proses \textit{checkout} kode pada runner. Selanjutnya, workflow
akan menyiapkan lingkungan eksekusi, seperti menginstal dependensi dan
menentukan versi bahasa pemrograman yang digunakan. Tahap ini memastikan bahwa
setiap eksekusi workflow berjalan dalam kondisi yang konsisten dan dapat
direproduksi.

Tahap berikutnya adalah pengujian otomatis. Dalam workflow CI, pengujian unit
dan pengujian integrasi dijalankan untuk memverifikasi bahwa perubahan kode
tidak merusak fungsionalitas yang sudah ada. Kegagalan pada tahap ini akan
menghentikan workflow dan memberikan umpan balik langsung kepada pengembang,
sehingga perbaikan dapat dilakukan segera.

Jika seluruh pengujian berhasil, workflow dapat dilanjutkan ke tahap
deployment. Pada studi kasus ini, keberhasilan workflow CI akan memicu
workflow lanjutan melalui event \texttt{workflow\_run}. Workflow deployment
tersebut dijalankan pada \textit{self-hosted runner}, yang memiliki akses
langsung ke Docker Engine dan lingkungan target. Dengan mekanisme ini,
deployment hanya dilakukan pada kode yang telah diverifikasi oleh CI.

Secara keseluruhan, workflow CI/CD membentuk sebuah pipa eksekusi yang
menghubungkan perubahan kode dengan sistem yang berjalan. Setiap tahap dalam
workflow menghasilkan sinyal keberhasilan atau kegagalan yang bersifat
eksplisit, sehingga seluruh proses pengembangan menjadi transparan,
terobservasi, dan dapat diaudit. Pendekatan ini sangat penting dalam konteks
pengembangan perangkat lunak modern yang menuntut kecepatan, kualitas, dan
reliabilitas secara simultan.

\begin{figure}[phtb]
\centering
\scalebox{0.95}{%
\begin{tikzpicture}[
  font=\small\bfseries,
  node distance=9mm,
  box/.style={
    draw,
    rounded corners=2mm,
    align=center,
    minimum width=46mm,
    minimum height=9mm,
    fill=blue!10
  },
  eventbox/.style={box,fill=gray!15},
  cibox/.style={box,fill=green!15},
  deploybox/.style={box,fill=orange!20},
  runnerbox/.style={box,fill=purple!15},
  arrow/.style={-Latex,thick},
  dottedarrow/.style={-Latex,thick,dotted}
]

% --- top events ---
\node[eventbox] (dev) {Developer\\Commit \& Push};
\node[eventbox, right=14mm of dev] (pr) {Pull Request};

% --- CI pipeline ---
\node[cibox, below=of dev] (ci) {CI Workflow\\CI Tests (session-04)};
\node[runnerbox, right=14mm of ci] (ghrunner) {GitHub-hosted Runner\\ubuntu-latest};

\node[cibox, below=of ci] (unit) {Unit Tests\\\texttt{pytest -q tests/unit}};
\node[cibox, below=of unit] (integ) {Integration Tests\\\texttt{docker compose up} + \texttt{pytest}};
\node[eventbox, below=of integ] (result) {CI Result\\success / failure};

% --- deploy pipeline ---
\node[deploybox, below=of result] (deploywf) {Deploy Workflow\\\texttt{deploy-local.yml}};
\node[runnerbox, right=14mm of deploywf] (self) {Self-hosted Runner\\Linux, X64};

\node[deploybox, below=of deploywf] (checkout) {Checkout Code\\branch: \texttt{main}};
\node[deploybox, below=of checkout] (deploy) {Docker Compose Deploy\\\texttt{down} $\rightarrow$ \texttt{up -d --build}};
\node[eventbox, right=14mm of deploy] (running) {Local Stack Running\\\texttt{http://localhost:8088}};

% --- arrows ---
\draw[arrow] (dev) -- (ci);
\draw[arrow] (pr) -- (ci);

\draw[dottedarrow] (ci) -- (ghrunner);
\draw[arrow] (ci) -- (unit);
\draw[arrow] (unit) -- (integ);
\draw[arrow] (integ) -- (result);

\draw[dottedarrow] (result) -- node[right]{\texttt{workflow\_run} (success)} (deploywf);
\draw[dottedarrow] (deploywf) -- (self);

\draw[arrow] (deploywf) -- (checkout);
\draw[arrow] (checkout) -- (deploy);
\draw[arrow] (deploy) -- (running);

\end{tikzpicture}%
}
\caption{Diagram workflow CI/CD pada studi kasus \texttt{session-04}. Commit dan pull request memicu workflow CI pada runner GitHub-hosted. Jika CI berstatus \texttt{success}, event \texttt{workflow\_run} memicu workflow deploy pada self-hosted runner untuk melakukan deployment menggunakan Docker Compose.}
\label{fig:cicd-workflow-session-04}
\end{figure}



\section{Contoh Studi Kasus}

\begin{figure}[htbp]
\centering
\scalebox{0.9}{
\begin{tikzpicture}[
  font=\small\bfseries,
  node distance=20mm and 16mm,
  box/.style={
    draw,
    align=center,
    minimum width=34mm,
    minimum height=10mm,
    fill=blue!10
  },
  storebox/.style={box,fill=purple!10},
  brokerbox/.style={box,fill=orange!15},
  apiwebbox/.style={box,fill=green!12},
  gatewaybox/.style={box,fill=gray!15},
  workerbox/.style={box,fill=yellow!18},
  annot/.style={font=\scriptsize\itshape, text=black!70},
  arrow/.style={-Latex,thick},
  dottedarrow/.style={-Latex,thick,dotted}
]

% --- Row 1 (top): Browser - Gateway - Redis ---
\node[gatewaybox] (client) {Browser / Client\\{\scriptsize User}};
\node[gatewaybox, right=of client] (gateway) {Gateway\\Nginx\\{\scriptsize :8088}};
\node[brokerbox, right=of gateway] (redis) {Redis\\Queue/State\\{\scriptsize :6379}};

\node[annot, above=1mm of client] {HTTP Request};
\node[annot, above=1mm of gateway] {Same-origin routing};
\node[annot, above=1mm of redis] {jobs:queue:dev};

% --- Row 2 (middle): Web (left) - API (center) - Worker (right) ---
\node[apiwebbox, below=of client] (web) {Web Service\\Player + MP3\\{\scriptsize :8080}};
\node[apiwebbox, below=of gateway, xshift=-11mm] (api) {API Service\\FastAPI\\{\scriptsize :8000 + /healthz}};
\node[workerbox, below=of redis] (worker) {Worker\\Piper + ffmpeg\\{\scriptsize replicas: 1}};

\node[annot, below=1mm of web] {Serve UI + stream MP3};
\node[annot, below=1mm of api] {Enqueue job + status};
\node[annot, below=1mm of worker] {TTS $\rightarrow$ MP3};

% --- Row 3 (bottom): MinIO centered under API (middle column) ---
\node[storebox, below=of api] (minio) {MinIO\\S3 Storage\\{\scriptsize :9000 / :9001}};
\node[annot, below=1mm of minio] {Bucket: tts-dev};

% =========================================================
% Edges (adjusted after swapping Web and API)
% =========================================================

% Browser -> Gateway
\draw[arrow] (client.east) -- node[above]{HTTP} (gateway.west);

% Gateway routes down: "/" to Web, "/api/*" to API (two vertical drops)
\draw[arrow] (gateway.south) -- node[below, yshift=-1mm]{\texttt{/}} (web.north);
\draw[arrow] (gateway.south) -- node[right]{\texttt{/api/*}} (api.north);

% API -> Redis (up-right curve)
\draw[arrow] (api.north east) -- node[right, yshift=-2mm]{enqueue/status} (redis.south west);

% Worker -> Redis (up-left curve)
\draw[arrow] (worker.north) -- node[right]{dequeue job} (redis.south);

% Worker -> API (straight horizontal)
\draw[arrow] (worker) -- node[above]{callback/update} (api);

% Worker -> MinIO (down to middle-bottom)
\draw[arrow] (worker) -- node[right, xshift=2mm]{PUT MP3 (S3 API)} (minio);

% Web -> MinIO (read MP3) : curve down-right to MinIO
\draw[arrow] (web.south east) -- node[left, xshift=-2mm]{GET MP3 (S3 API)} (minio);

% Web -> Browser (UI/MP3 delivery)
\draw[arrow] (web.north) -- node[right, yshift=5mm]{HTML/JS + MP3 URL} (client.south);


\end{tikzpicture}
}
\caption{Arsitektur \texttt{docker-compose} untuk TTS case study: client mengakses \textit{gateway} Nginx (\texttt{:8088}) yang merutekan \texttt{/} ke layanan \textit{web} dan \texttt{/api/*} ke layanan \textit{api}. Layanan \textit{api} mengantrikan job ke Redis, \textit{worker} mengambil job dari Redis, melakukan sintesis TTS (Piper) dan konversi MP3 (ffmpeg), lalu menyimpan hasil ke MinIO (S3). Layanan \textit{web} menyajikan UI dan mengambil MP3 dari MinIO untuk diputar oleh client.}
\label{fig:tts-compose-architecture}
\end{figure}




Sebagai contoh konkret penerapan konsep CI/CD dan orkestrasi layanan berbasis
container, studi kasus ini menggunakan sistem \textit{text-to-speech} (TTS)
yang dijalankan secara lokal menggunakan \texttt{docker-compose}. Diagram pada
%Gambar~\ref{fig:tts-compose-architecture} menggambarkan arsitektur lengkap
sistem, hubungan antar layanan, serta alur data dari sudut pandang pengguna
hingga proses pemrosesan di backend.

Interaksi sistem dimulai dari sisi pengguna melalui browser atau klien HTTP.
Permintaan dari klien dikirim ke \textit{gateway} berbasis Nginx yang berjalan
pada port \texttt{:8088}. Gateway ini berfungsi sebagai \textit{reverse proxy}
ringan untuk menjaga \textit{same-origin policy}, dengan merutekan permintaan
ke path \texttt{/} menuju layanan \textit{web} dan permintaan ke
\texttt{/api/*} menuju layanan \textit{api}. Dengan pendekatan ini, klien tidak
perlu berkomunikasi langsung dengan beberapa port atau service berbeda.

Layanan \textit{api} diimplementasikan menggunakan FastAPI dan bertanggung
jawab sebagai titik masuk logika aplikasi. Layanan ini menerima permintaan TTS
dari klien, melakukan validasi, serta mencatat status permintaan. Untuk
mengelola proses asinkron dan menjaga responsivitas sistem, layanan
\textit{api} tidak melakukan sintesis suara secara langsung, melainkan
mengantrikan job ke Redis yang berperan sebagai \textit{queue} dan penyimpan
state sementara. Mekanisme ini memungkinkan sistem menangani banyak permintaan
tanpa memblokir thread HTTP.

Redis berfungsi sebagai komponen perantara yang ringan dan efisien untuk
menyimpan antrian pekerjaan (\texttt{jobs:queue:dev}) serta status pemrosesan.
Keberadaan Redis memungkinkan pemisahan yang jelas antara komponen penerima
permintaan (API) dan komponen pemroses komputasi berat (worker). Pemisahan ini
meningkatkan skalabilitas dan kejelasan arsitektur.

Layanan \textit{worker} merupakan komponen pemrosesan utama dalam studi kasus
ini. Worker secara periodik mengambil job dari Redis, kemudian menjalankan
proses sintesis suara menggunakan \textit{Piper} sebagai engine TTS dan
\texttt{ffmpeg} untuk menghasilkan berkas MP3. Setelah proses sintesis
selesai, worker menyimpan hasil MP3 ke penyimpanan objek MinIO menggunakan API
S3. Pendekatan ini menjadikan worker bersifat stateless, karena artefak hasil
pemrosesan tidak disimpan pada container worker itu sendiri.

MinIO berfungsi sebagai penyimpanan objek yang kompatibel dengan S3 dan
digunakan untuk menyimpan berkas MP3 hasil sintesis. MinIO dipilih karena
ringan, mudah dijalankan secara lokal, dan memiliki antarmuka yang serupa
dengan layanan penyimpanan cloud. Dengan menggunakan MinIO, arsitektur sistem
dapat dengan mudah dimigrasikan ke lingkungan cloud tanpa perubahan signifikan
pada kode aplikasi.

Layanan \textit{web} berperan sebagai antarmuka pengguna. Layanan ini menyajikan
halaman HTML dan JavaScript sederhana untuk memutar audio, serta bertindak
sebagai penyedia berkas MP3 dengan mengambilnya dari MinIO. Dengan memisahkan
fungsi web dan API, sistem memperoleh batas tanggung jawab yang jelas antara
penyajian antarmuka dan logika bisnis.

Seluruh layanan dijalankan dan dikoordinasikan menggunakan
\texttt{docker-compose}. Relasi dependensi antar layanan, seperti API yang
bergantung pada Redis dan worker yang bergantung pada API, Redis, dan MinIO,
ditentukan secara eksplisit dalam berkas \texttt{docker-compose.yml}. Hal ini
memastikan bahwa layanan dijalankan dalam urutan yang tepat dan dapat
dikontrol secara deterministik pada saat deployment lokal.

Studi kasus ini mencerminkan pola arsitektur yang umum digunakan pada sistem
terdistribusi modern, yaitu pemisahan tanggung jawab antar layanan,
pemrosesan asinkron melalui message queue, serta penggunaan penyimpanan objek
untuk artefak hasil komputasi. Melalui contoh ini, mahasiswa dapat memahami
bagaimana pipeline CI/CD, orkestrasi container, dan desain arsitektur layanan
bekerja secara terpadu dalam satu sistem yang realistis namun tetap
terkendali untuk tujuan pembelajaran.


\section{Menjalankan Contoh}

Bagian ini menjelaskan cara menjalankan contoh sistem TTS secara lokal
menggunakan \texttt{docker compose}, serta cara mengakses layanan yang
tersedia baik melalui command-line maupun melalui web browser. Seluruh
langkah diasumsikan dijalankan pada mesin lokal Ubuntu yang telah terpasang
Docker Engine dan Docker Compose plugin.

Langkah pertama adalah memastikan bahwa tidak ada container lama yang masih
berjalan. Hal ini penting untuk menghindari konflik port, state lama pada
container, atau penggunaan image yang sudah tidak relevan. Setelah itu,
seluruh service akan dibangun ulang dan dijalankan.

\begin{lstlisting}[language=bash]
sudo docker compose down
sudo docker compose build
sudo docker compose up
\end{lstlisting}

Perintah \texttt{docker compose down} menghentikan seluruh container yang
sebelumnya berjalan. Perintah \texttt{docker compose build} membangun ulang
image Docker untuk setiap service berdasarkan Dockerfile yang tersedia.
Selanjutnya, \texttt{docker compose up} menjalankan seluruh service secara
bersamaan dan menampilkan log secara langsung di terminal. Pada tahap ini,
API, web server, worker, Redis, MinIO, dan gateway Nginx akan mulai berjalan.

Setelah seluruh service berjalan dengan baik, sistem siap menerima
permintaan text-to-speech. Permintaan dapat dikirimkan melalui API menggunakan
HTTP request. Contoh berikut menunjukkan cara mengirimkan teks untuk diproses
menjadi suara menggunakan perintah \texttt{curl}.

\begin{lstlisting}[language=bash]
# submit a text
curl -X POST http://localhost:8088/api/jobs \
  -H "Content-Type: application/json" \
  -d '{"text":"Hello world this is a test"}'
\end{lstlisting}

Perintah di atas akan mengirimkan teks ke layanan API melalui gateway pada
port \texttt{8088}. API akan mengembalikan respons berupa \textit{job ID}
unik yang merepresentasikan permintaan TTS tersebut. Job ini kemudian
dimasukkan ke antrian Redis dan diproses secara asinkron oleh worker.

Status pemrosesan job dapat diperiksa menggunakan job ID yang diperoleh dari
respons sebelumnya. Contoh berikut menunjukkan cara mengambil status dan
hasil pemrosesan job melalui API.

\begin{lstlisting}[language=bash]
# get the result
curl http://localhost:8088/api/jobs/98627818-6d12-4d85-84ad-7f6d777d8e54
\end{lstlisting}

Jika proses TTS telah selesai, respons API akan menunjukkan bahwa job telah
berhasil diproses dan berkas MP3 telah tersedia. Berkas audio hasil sintesis
dapat diakses melalui endpoint MP3 yang disediakan oleh layanan web.

\begin{lstlisting}[language=bash]
# open the speech file (add -o output.mp3 to save the file)
curl -I http://localhost:8088/mp3/98627818-6d12-4d85-84ad-7f6d777d8e54.mp3
\end{lstlisting}

URL MP3 tersebut tidak hanya dapat diakses melalui \texttt{curl}, tetapi
juga dapat dibuka langsung melalui web browser. Dengan menyalin URL
\texttt{http://localhost:8088/mp3/<job-id>.mp3} ke address bar browser,
audio hasil text-to-speech akan langsung diputar atau diunduh oleh browser,
tergantung konfigurasi browser yang digunakan.

Selain mengakses berkas MP3 secara langsung, pengguna juga dapat membuka
antarmuka web yang disediakan oleh layanan \textit{web}. Antarmuka ini dapat
diakses melalui browser pada alamat berikut:

\begin{lstlisting}[language=bash]
http://localhost:8088/
\end{lstlisting}

Halaman web ini berfungsi sebagai pemutar audio sederhana dan antarmuka
pengguna untuk mengakses hasil text-to-speech. Dengan demikian, sistem dapat
diakses baik melalui pendekatan API-centric (menggunakan \texttt{curl} atau
HTTP client lain) maupun melalui web browser, tanpa perubahan pada arsitektur
backend.

Bagian ini menegaskan bahwa layanan yang dijalankan melalui Docker Compose
bersifat reusable dan dapat diakses melalui berbagai klien, sekaligus
memberikan ilustrasi nyata tentang integrasi antara API, worker asinkron,
penyimpanan objek, dan antarmuka web dalam satu sistem terdistribusi lokal.


\section{Tutorial}

Bagian ini menjelaskan tahapan awal yang harus dilakukan sebelum menjalankan
eksperimen dan praktikum pada modul ini. Seluruh langkah diasumsikan
dijalankan pada sistem operasi Ubuntu Linux.

\begin{enumerate}

  \item \textbf{Membuat akun GitHub}

  GitHub merupakan platform utama yang digunakan untuk menyimpan kode sumber,
  mengelola versi perangkat lunak, serta menjalankan pipeline CI/CD melalui
  GitHub Actions. Setiap mahasiswa diwajibkan memiliki akun GitHub aktif.
  Akun dapat dibuat dengan mengunjungi \texttt{https://github.com} dan
  melakukan proses pendaftaran menggunakan email yang valid. Username yang
  dipilih sebaiknya bersifat profesional karena akan muncul pada riwayat
  commit, URL repository, serta log CI/CD.

  \item \textbf{Menginstal Git secara lokal}

  Git adalah sistem \textit{distributed version control} yang wajib tersedia
  di lingkungan pengembangan lokal. Pada Ubuntu, Git dapat diinstal
  menggunakan \texttt{apt}. Setelah instalasi, versi Git perlu diverifikasi
  untuk memastikan bahwa instalasi berjalan dengan benar.

  \begin{lstlisting}[language=bash]
sudo apt update
sudo apt install -y git
git --version
  \end{lstlisting}

  Jika perintah di atas menampilkan versi Git, maka Git telah berhasil
  terinstal dan siap digunakan.

  \item \textbf{Mengonfigurasi dan mengautentikasi Git dengan GitHub}

  Sebelum menggunakan Git, identitas pengguna perlu dikonfigurasikan.
  Informasi ini akan tercatat secara permanen pada setiap commit yang dibuat.
  Konfigurasi dilakukan satu kali pada mesin lokal dengan perintah berikut:

  \begin{lstlisting}[language=bash]
git config --global user.name "Nama Lengkap Anda"
git config --global user.email "email@contoh.com"
git config --global --list
  \end{lstlisting}

  Autentikasi Git ke GitHub tidak lagi menggunakan password, melainkan
  mekanisme berbasis token yang akan dikelola secara otomatis melalui
  GitHub CLI pada tahap selanjutnya.

  \item \textbf{Menggunakan repository GitHub untuk modul ini}

  Repository utama yang digunakan dalam modul ini telah disediakan dan dapat
  diakses melalui alamat berikut:

  \begin{lstlisting}[language=bash]
https://github.com/alfa-yohannis/advanced-software-engineering
  \end{lstlisting}

  Repository ini berisi struktur proyek per sesi, contoh aplikasi berbasis
  layanan terdistribusi, serta konfigurasi CI/CD yang akan digunakan
  sepanjang perkuliahan. Mahasiswa tidak perlu membuat repository baru,
  tetapi langsung menggunakan repository ini sebagai basis pembelajaran.

  \item \textbf{Melakukan clone repository ke komputer lokal}

  Proses \textit{clone} digunakan untuk menyalin seluruh isi repository dari
  GitHub ke lingkungan lokal agar dapat dijalankan, dimodifikasi, dan diuji.
  Clone repository dilakukan dengan perintah berikut:

  \begin{lstlisting}[language=bash]
git clone https://github.com/alfa-yohannis/advanced-software-engineering.git
cd advanced-software-engineering
git remote -v
  \end{lstlisting}

  Jika URL repository GitHub tampil pada hasil perintah
  \texttt{git remote -v}, maka proses clone berhasil dan lingkungan lokal
  telah terhubung dengan repository GitHub.


\item \textbf{Menginstal GitHub CLI (\texttt{gh})}

GitHub CLI (\texttt{gh}) adalah alat bantu resmi dari GitHub yang mempermudah
interaksi antara mesin lokal dan GitHub. Dengan \texttt{gh}, autentikasi,
manajemen repository, serta pemantauan workflow CI/CD dapat dilakukan langsung
melalui terminal. Pada Ubuntu, GitHub CLI dapat diinstal menggunakan
\texttt{apt} sebagai berikut:

\begin{lstlisting}[language=bash]
sudo apt update
sudo apt install -y gh
gh --version
\end{lstlisting}

Jika versi \texttt{gh} berhasil ditampilkan, maka GitHub CLI telah terinstal
dan siap digunakan.

\item \textbf{Mengautentikasi \texttt{gh} dengan GitHub}

Setelah GitHub CLI terinstal, langkah berikutnya adalah melakukan autentikasi
ke akun GitHub. Proses ini akan menghubungkan mesin lokal dengan akun GitHub
tanpa perlu memasukkan username dan password setiap kali melakukan operasi Git.
Autentikasi dilakukan dengan perintah berikut:

\begin{lstlisting}[language=bash]
gh auth login
\end{lstlisting}

Pada proses login, pilih GitHub.com, metode HTTPS, dan autentikasi melalui
browser. Setelah proses selesai, status autentikasi dapat diverifikasi
dengan perintah berikut:

\begin{lstlisting}[language=bash]
gh auth status
\end{lstlisting}

Jika status login aktif, maka Git, GitHub, dan GitHub CLI telah terintegrasi
dengan benar.

\item \textbf{Menginstal Docker Engine}

Docker Engine digunakan untuk menjalankan aplikasi dalam bentuk container.
Seluruh eksperimen pada modul ini menggunakan container sebagai unit eksekusi
utama. Pada Ubuntu, Docker Engine dapat diinstal melalui repository bawaan
sebagai berikut:

\begin{lstlisting}[language=bash]
sudo apt update
sudo apt install -y docker.io
docker version
\end{lstlisting}

Jika informasi versi Docker tampil, maka Docker Engine telah berhasil
terinstal. Agar Docker dapat dijalankan tanpa menggunakan \texttt{sudo},
pengguna perlu ditambahkan ke grup \texttt{docker}:

\begin{lstlisting}[language=bash]
sudo usermod -aG docker $USER
# logout dan login kembali
docker ps
\end{lstlisting}

\item \textbf{Menginstal Docker Compose plugin}

Docker Compose digunakan untuk menjalankan sistem yang terdiri dari beberapa
service secara bersamaan, seperti API, database, worker, dan reverse proxy.
Versi modern Docker menggunakan Compose sebagai plugin terintegrasi.
Ketersediaan Docker Compose dapat diperiksa dengan perintah berikut:

\begin{lstlisting}[language=bash]
docker compose version
\end{lstlisting}

Jika perintah tersebut belum tersedia, Docker Compose plugin dapat diinstal
menggunakan \texttt{apt}:

\begin{lstlisting}[language=bash]
sudo apt install -y docker-compose-plugin
docker compose version
\end{lstlisting}

Setelah Docker Compose tersedia, lingkungan lokal telah siap untuk menjalankan
aplikasi multi-service menggunakan file \texttt{docker-compose.yml}.


  \item \textbf{Membuat direktori runner}

GitHub Actions runner dijalankan sebagai proses mandiri pada mesin lokal
atau server. Oleh karena itu, langkah pertama adalah menyiapkan direktori
khusus untuk runner agar file biner dan konfigurasi tidak tercampur dengan
kode proyek. Direktori ini umumnya diletakkan pada home directory pengguna.

\begin{lstlisting}[language=bash]
mkdir actions-runner && cd actions-runner
\end{lstlisting}

Setelah perintah ini dijalankan, seluruh proses instalasi dan konfigurasi
runner akan dilakukan di dalam direktori \texttt{actions-runner}.

\item \textbf{Mengunduh paket GitHub Actions runner}

GitHub menyediakan runner resmi dalam bentuk arsip terkompresi.
Unduh paket runner untuk arsitektur Linux x64 menggunakan \texttt{curl}
sebagai berikut:

\begin{lstlisting}[language=bash]
curl -o actions-runner-linux-x64-2.331.0.tar.gz -L \
https://github.com/actions/runner/releases/download/v2.331.0/actions-runner-linux-x64-2.331.0.tar.gz
\end{lstlisting}

File arsip ini berisi executable runner beserta skrip konfigurasi yang
diperlukan untuk menghubungkan runner dengan repository GitHub.

\item \textbf{Memvalidasi checksum paket runner}

Sebelum mengekstrak arsip, integritas file perlu divalidasi untuk memastikan
bahwa paket tidak rusak atau dimodifikasi selama proses unduhan.
Validasi dilakukan menggunakan checksum SHA-256 yang disediakan oleh GitHub.

\begin{lstlisting}[language=bash]
echo "<SHA256_CHECKSUM>  actions-runner-linux-x64-2.331.0.tar.gz" | shasum -a 256 -c
\end{lstlisting}

Jika hasilnya menunjukkan status \texttt{OK}, maka arsip runner aman untuk
diekstrak dan digunakan.

\item \textbf{Mengekstrak arsip runner}

Setelah checksum tervalidasi, arsip runner diekstrak menggunakan perintah
\texttt{tar}. Proses ini akan menghasilkan sejumlah file dan direktori,
termasuk skrip \texttt{config.sh} dan \texttt{run.sh}.

\begin{lstlisting}[language=bash]
tar xzf actions-runner-linux-x64-2.331.0.tar.gz
\end{lstlisting}

Setelah ekstraksi selesai, direktori \texttt{actions-runner} berisi seluruh
komponen yang dibutuhkan untuk menjalankan GitHub Actions runner.

\item \textbf{Membuat token registrasi GitHub Actions runner}

Agar runner dapat terhubung dengan repository GitHub, diperlukan token
registrasi sementara. Token ini dibuat melalui antarmuka GitHub dengan
langkah berikut: buka halaman repository
\texttt{Settings > Actions > Runners > New self-hosted runner}.
GitHub akan menghasilkan token yang hanya berlaku dalam waktu terbatas
(beberapa menit).

Token ini akan digunakan pada tahap konfigurasi runner dan tidak perlu
disimpan secara permanen.

\item \textbf{Mengonfigurasi runner}

Langkah terakhir adalah mengonfigurasi runner agar terdaftar pada repository
GitHub. Proses konfigurasi dilakukan menggunakan skrip \texttt{config.sh}
dengan memasukkan URL repository dan token registrasi yang telah dibuat.

\begin{lstlisting}[language=bash]
./config.sh \
  --url https://github.com/alfa-yohannis/advanced-software-engineering \
  --token <TOKEN>
\end{lstlisting}

Selama proses konfigurasi, Anda dapat menentukan nama runner dan label
(default dapat digunakan). Jika konfigurasi berhasil, runner akan muncul
sebagai \textit{idle} pada halaman GitHub Actions dan siap menjalankan job
CI/CD dari workflow.


\item \textbf{Menentukan nama runner}

Pada saat proses konfigurasi runner dijalankan, sistem akan meminta nama
runner. Nama ini digunakan untuk mengidentifikasi runner pada halaman
GitHub Actions dan sebaiknya mencerminkan mesin atau perannya. Contoh nama
yang baik adalah \texttt{local-linux-runner} atau \texttt{deploy-node-01}.
Jika tidak ditentukan, GitHub akan memberikan nama default berdasarkan
hostname mesin.

Nama runner ini akan muncul pada daftar \textit{self-hosted runners}
di repository GitHub dan mempermudah proses debugging maupun monitoring.

\item \textbf{Menentukan label runner (\texttt{self-hosted}, \texttt{Linux}, \texttt{X64})}

Label digunakan oleh GitHub Actions untuk mencocokkan job workflow dengan
runner yang sesuai. Pada modul ini, workflow dirancang untuk berjalan pada
runner dengan label \texttt{self-hosted}, \texttt{Linux}, dan \texttt{X64}.
Label-label ini harus ditetapkan saat proses konfigurasi runner.

Jika diminta memasukkan label secara interaktif, pastikan ketiga label
tersebut ada dan dipisahkan dengan koma. Label ini memungkinkan workflow
menggunakan deklarasi berikut pada file YAML:

\begin{lstlisting}[language=bash]
runs-on: [self-hosted, Linux, X64]
\end{lstlisting}

Jika label tidak sesuai, job CI/CD tidak akan pernah dijalankan karena
tidak menemukan runner yang cocok.

\item \textbf{Menentukan direktori kerja runner}

Runner membutuhkan direktori kerja untuk mengeksekusi job dan menyimpan
artefak sementara seperti source code, log, dan hasil build. Secara default,
GitHub Actions akan menggunakan subdirektori \texttt{\_work} di dalam folder
runner. Direktori ini dapat diterima dan tidak perlu diubah kecuali terdapat
kebutuhan khusus, seperti penggunaan disk terpisah.

Direktori kerja ini akan diisi dan dibersihkan secara otomatis oleh runner
setiap kali job dijalankan.

\item \textbf{Menjalankan self-hosted runner}

Setelah konfigurasi selesai, runner dapat dijalankan secara manual untuk
pertama kali menggunakan skrip \texttt{run.sh}. Perintah ini akan
menghubungkan runner ke GitHub dan menunggu job dari workflow.

\begin{lstlisting}[language=bash]
./run.sh
\end{lstlisting}

Jika runner berhasil dijalankan, terminal akan menampilkan status bahwa
runner sedang menunggu job (\textit{Listening for Jobs}). Pada saat ini,
runner juga akan muncul sebagai \textit{Idle} di halaman GitHub Actions.

Untuk penggunaan jangka panjang di server, runner sebaiknya dijalankan
sebagai service sistem, namun untuk tujuan praktikum, mode manual ini
sudah mencukupi.

\item \textbf{Melihat daftar workflow yang tersedia}

Setelah runner aktif, langkah terakhir adalah memastikan bahwa repository
memiliki workflow yang dapat dijalankan. Daftar workflow dapat dilihat
menggunakan GitHub CLI dengan perintah berikut:

\begin{lstlisting}[language=bash]
gh workflow list
\end{lstlisting}

Perintah ini akan menampilkan nama workflow, status, dan event pemicunya.
Jika workflow muncul pada daftar ini dan runner sedang aktif, maka sistem
siap untuk menjalankan pipeline CI/CD secara penuh.


  \item \textbf{Melakukan commit perubahan secara lokal}

Setelah melakukan perubahan pada kode atau konfigurasi, langkah pertama
dalam alur CI/CD adalah menyimpan perubahan tersebut ke dalam repository
lokal menggunakan commit Git. Commit berfungsi sebagai unit perubahan yang
akan dilacak, diuji, dan dieksekusi oleh pipeline CI.

Sebelum commit, periksa status repository untuk memastikan file yang
berubah sudah sesuai:

\begin{lstlisting}[language=bash]
git status
\end{lstlisting}

Tambahkan perubahan ke staging area dan buat commit dengan pesan yang
deskriptif:

\begin{lstlisting}[language=bash]
git add .
git commit -m "chore: update configuration for CI test"
\end{lstlisting}

Commit ini masih bersifat lokal dan belum dikirim ke GitHub.

\item \textbf{Mengirim commit ke branch \texttt{main}}

Agar perubahan dapat diproses oleh GitHub Actions, commit lokal perlu
dikirim ke repository GitHub, khususnya ke branch \texttt{main} yang
digunakan sebagai branch utama pada modul ini.

\begin{lstlisting}[language=bash]
git push origin main
\end{lstlisting}

Setelah perintah ini dijalankan, GitHub akan menerima perubahan dan
event \texttt{push} akan menjadi salah satu pemicu workflow CI.

\item \textbf{Menjalankan workflow CI secara manual}

Selain dipicu otomatis oleh event \texttt{push}, workflow CI juga dapat
dijalankan secara manual menggunakan GitHub CLI. Hal ini berguna untuk
pengujian atau debugging pipeline tanpa perlu membuat commit baru.

Workflow dapat dijalankan menggunakan nama file workflow sebagai berikut:

\begin{lstlisting}[language=bash]
gh workflow run tests.yml
\end{lstlisting}

Perintah ini akan memicu workflow CI dengan konfigurasi default pada
branch aktif.

\item \textbf{Menjalankan workflow CI pada branch \texttt{main}}

Untuk memastikan workflow dijalankan secara eksplisit pada branch
\texttt{main}, GitHub CLI menyediakan opsi \texttt{--ref}. Opsi ini
digunakan ketika repository memiliki beberapa branch aktif.

\begin{lstlisting}[language=bash]
gh workflow run "CI Tests (session-04)" --ref main
\end{lstlisting}

Dengan perintah ini, workflow \texttt{CI Tests (session-04)} akan dijalankan
menggunakan kode terbaru pada branch \texttt{main}.

\item \textbf{Melihat daftar eksekusi workflow}

Setelah workflow dijalankan, status dan hasil eksekusi dapat dipantau
langsung dari terminal menggunakan GitHub CLI. Daftar eksekusi workflow
ditampilkan dengan perintah berikut:

\begin{lstlisting}[language=bash]
gh run list
\end{lstlisting}

Perintah ini akan menampilkan informasi seperti nama workflow, branch,
status eksekusi, dan waktu eksekusi. Dengan demikian, proses CI/CD dapat
dipantau tanpa harus membuka antarmuka web GitHub.


  
  \item \textbf{Melihat daftar eksekusi workflow CI}

Setelah workflow CI dijalankan, semua eksekusi workflow dapat dilihat langsung
melalui terminal menggunakan GitHub CLI. Untuk membatasi tampilan hanya pada
workflow \texttt{CI Tests (session-04)}, gunakan perintah berikut:

\begin{lstlisting}[language=bash]
gh run list --workflow "CI Tests (session-04)"
\end{lstlisting}

Perintah ini menampilkan daftar eksekusi workflow beserta informasi penting
seperti branch, status, dan waktu eksekusi. Daftar ini berguna untuk
mengidentifikasi run terbaru yang sedang atau telah dieksekusi.

\item \textbf{Memantau eksekusi workflow secara real-time}

GitHub CLI menyediakan mekanisme untuk memantau proses eksekusi workflow
secara real-time dari terminal. Fitur ini sangat berguna untuk memahami
tahapan CI yang sedang berjalan, seperti proses instalasi dependensi,
pengujian unit, dan pengujian integrasi.

\begin{lstlisting}[language=bash]
gh run watch
\end{lstlisting}

Perintah ini akan menampilkan log workflow yang sedang berjalan hingga
selesai atau dihentikan secara manual.

\item \textbf{Memantau eksekusi workflow hingga selesai dengan status keluar}

Untuk keperluan otomatisasi atau skrip, eksekusi workflow dapat dipantau
hingga selesai dengan mengembalikan status exit sesuai hasil workflow.
Perintah ini akan berhenti secara otomatis ketika workflow selesai,
dan mengembalikan kode keluar non-zero jika workflow gagal.

\begin{lstlisting}[language=bash]
gh run watch --exit-status
\end{lstlisting}

Opsi ini sangat berguna ketika pemantauan workflow dilakukan sebagai bagian
dari proses yang lebih besar, misalnya sebelum melanjutkan ke tahap deploy.

\item \textbf{Mengambil ID eksekusi CI terbaru}

Setiap eksekusi workflow memiliki ID unik yang dapat digunakan untuk
mengambil detail lebih lanjut, seperti log spesifik atau artefak.
ID eksekusi workflow CI terbaru pada branch \texttt{main} dapat diperoleh
menggunakan perintah berikut:

\begin{lstlisting}[language=bash]
gh run list \
  --workflow "CI Tests (session-04)" \
  --branch main \
  --limit 1 \
  --json databaseId \
  --jq '.[0].databaseId'
\end{lstlisting}

Perintah ini mengembalikan nilai \texttt{databaseId} dari eksekusi workflow
terbaru yang dijalankan pada branch \texttt{main}.

\item \textbf{Workflow CI selesai dengan sukses}

Jika seluruh tahapan dalam workflow CI selesai tanpa error, maka status
workflow akan ditandai sebagai \texttt{success}. Status ini menunjukkan bahwa
seluruh pengujian unit dan integrasi telah lulus, serta kode siap untuk
melanjutkan ke tahap berikutnya, seperti proses deploy menggunakan
self-hosted runner.

Keberhasilan workflow CI merupakan prasyarat utama sebelum sistem
melanjutkan ke eksekusi workflow lanjutan, misalnya \texttt{deploy-local.yml},
yang dipicu secara otomatis setelah CI berhasil.


  \item \textbf{GitHub memancarkan event penyelesaian \texttt{workflow\_run}}

Setelah workflow CI selesai dieksekusi, GitHub akan secara otomatis
memancarkan event bertipe \texttt{workflow\_run} dengan status
\texttt{completed}. Event ini membawa informasi penting, termasuk nama
workflow yang selesai dijalankan, branch yang digunakan, serta hasil akhir
eksekusi seperti \texttt{success} atau \texttt{failure}. Event inilah yang
digunakan sebagai pemicu untuk workflow lanjutan tanpa perlu interaksi
manual dari pengguna.

Event \texttt{workflow\_run} memungkinkan penyusunan pipeline bertahap,
di mana workflow berikutnya hanya dijalankan jika workflow sebelumnya
telah selesai dan memenuhi kondisi tertentu.

\item \textbf{Workflow deploy terpicu secara otomatis}

Workflow deploy dikonfigurasikan untuk mendengarkan event
\texttt{workflow\_run} dari workflow CI. Ketika event tersebut diterima
dengan status \texttt{success}, GitHub akan memicu workflow deploy secara
otomatis. Mekanisme ini memastikan bahwa proses deployment hanya dilakukan
jika seluruh pengujian unit dan integrasi telah berhasil dilewati.

Dengan pendekatan ini, tidak ada langkah deploy yang dijalankan pada kode
yang gagal diuji, sehingga konsistensi dan stabilitas sistem tetap terjaga.

\item \textbf{Job deployment menargetkan self-hosted runner}

Berbeda dengan workflow CI yang berjalan pada runner milik GitHub,
workflow deploy dikonfigurasikan untuk dijalankan pada self-hosted runner.
Hal ini ditentukan melalui deklarasi \texttt{runs-on: self-hosted} pada
file workflow. Dengan konfigurasi ini, GitHub akan mengirim job deployment
ke mesin lokal atau server yang telah diregistrasi sebagai runner.

Self-hosted runner memungkinkan proses deployment dijalankan langsung pada
lingkungan target, misalnya server lokal atau node khusus yang memiliki
akses ke Docker Engine dan Docker Compose.

\item \textbf{Self-hosted runner melakukan checkout branch \texttt{main}}

Ketika job deployment diterima, self-hosted runner terlebih dahulu mengambil
source code dari repository GitHub. Runner melakukan \textit{checkout} ke
branch \texttt{main} untuk memastikan bahwa kode yang digunakan pada tahap
deployment identik dengan kode yang telah lulus seluruh pengujian pada
workflow CI.

Proses ini dilakukan menggunakan action \texttt{actions/checkout}, sehingga
seluruh berkas konfigurasi dan definisi deployment (termasuk file
\texttt{docker-compose.yml}) tersedia secara lokal pada direktori kerja runner
dan siap digunakan oleh tahap-tahap berikutnya dalam workflow deploy.

  
\item \textbf{Menjalankan deployment aplikasi berbasis Docker Compose}

Setelah source code berhasil di-\textit{checkout} pada self-hosted runner,
tahap berikutnya adalah menjalankan proses deployment aplikasi secara otomatis
menggunakan Docker Compose. Pada studi kasus ini, deployment dilakukan dengan
menjalankan aplikasi secara lokal pada mesin runner, sehingga runner harus
memastikan bahwa tidak ada container lama yang masih berjalan dan menggunakan
resource atau port yang sama.

Langkah deployment ini didefinisikan secara eksplisit di dalam workflow file
\texttt{.github/workflows/deploy-local.yml}. Cuplikan berikut menunjukkan perintah yang
dieksekusi oleh self-hosted runner pada tahap deployment:

\begin{lstlisting}[language=bash]
- name: Run app locally (compose)
  run: |
    docker compose -f projects/session-04/docker-compose.yml down || true
    docker compose -f projects/session-04/docker-compose.yml up -d --build
    docker compose -f projects/session-04/docker-compose.yml ps
\end{lstlisting}

Perintah \texttt{docker compose down || true} digunakan untuk menghentikan
seluruh container yang mungkin masih berjalan dari deployment sebelumnya.
Operator \texttt{|| true} memastikan bahwa workflow tetap berlanjut meskipun
belum terdapat container aktif, sehingga tahap deployment bersifat idempoten
dan aman untuk dijalankan berulang kali.

Perintah \texttt{docker compose up -d --build} membangun ulang image Docker dan
menjalankan seluruh service dalam mode \textit{detached}. Dalam konteks
praktikum, pendekatan ini dipilih agar perubahan kode yang telah lulus CI dapat
langsung tercermin pada sistem yang berjalan tanpa bergantung pada image dari
registry eksternal.

Langkah terakhir, \texttt{docker compose ps}, digunakan untuk memverifikasi
status seluruh service yang dijalankan. Jika seluruh container berstatus
\texttt{Up}, maka deployment lokal dapat dianggap berhasil secara teknis dan
sistem berada pada kondisi runtime yang konsisten dengan kode terbaru pada
branch \texttt{main}.

\end{enumerate}


\section{Pertanyaan Diskusi}

Bagian ini membantu mahasiswa mengaitkan konsep CI/CD dengan praktik pada studi kasus TTS dan workflow \texttt{session-04}.

\subsection*{1) Mengapa CI perlu menjalankan unit test \emph{dan} integration test? Bukankah unit test sudah cukup?}
\textbf{Jawaban:} Unit test memverifikasi fungsi/komponen kecil secara terisolasi (misalnya validasi input, helper, atau logika domain) sehingga cepat dan mudah dilokalisasi ketika gagal. Namun, pada sistem multi-service seperti TTS (API -- Redis -- Worker -- MinIO -- Web -- Gateway), kegagalan sering muncul pada batas antar layanan: konfigurasi jaringan container, variabel environment, kontrak endpoint, dependensi runtime, atau urutan start-up. Integration test (misalnya E2E via \texttt{docker compose} + \texttt{pytest}) memverifikasi bahwa layanan saling terhubung dan alur utama benar-benar berjalan. Kombinasi keduanya menyeimbangkan \emph{kecepatan umpan balik} (unit) dan \emph{kepercayaan sistem} (integration).

\subsection*{2) Apa manfaat utama memisahkan workflow CI dan workflow deploy lewat event \texttt{workflow\_run}?}
\textbf{Jawaban:} Pemisahan ini membuat pipeline lebih modular dan lebih aman. CI fokus pada verifikasi kualitas (build, unit, integrasi) dan berjalan di runner GitHub-hosted yang bersifat ephemeral. Deploy berjalan hanya saat CI \texttt{success} dan menargetkan self-hosted runner yang punya akses ke lingkungan target (Docker Engine). Event \texttt{workflow\_run} bertindak sebagai ``gerbang'' formal: deployment menjadi konsekuensi dari verifikasi, bukan aksi manual yang rentan lupa atau salah versi.

\subsection*{3) Mengapa deployment dilakukan pada self-hosted runner, bukan GitHub-hosted runner?}
\textbf{Jawaban:} Deployment lokal membutuhkan akses langsung ke host yang menjalankan stack (mis. server lab atau mesin lokal) dan ke Docker daemon di lingkungan tersebut. GitHub-hosted runner tidak punya akses ke mesin target lokal Anda. Self-hosted runner berada \emph{di} lingkungan target sehingga dapat menjalankan \texttt{docker compose down/up}, mengecek port, volume, serta memastikan aplikasi benar-benar berjalan di host yang dimaksud.

\subsection*{4) Dalam studi kasus, mengapa API tidak melakukan sintesis TTS secara langsung, tetapi mengantrikan job ke Redis?}
\textbf{Jawaban:} Sintesis TTS dan konversi MP3 adalah pekerjaan relatif berat dan memakan waktu. Jika dilakukan langsung di API, request HTTP akan lama menggantung, memakan worker thread, dan menurunkan throughput. Dengan antrian Redis, API tetap responsif (cepat mengembalikan \textit{job id}), sementara worker memproses secara asinkron. Pola ini meningkatkan skalabilitas, memungkinkan penambahan replika worker, dan memisahkan tanggung jawab: API untuk orkestrasi, worker untuk komputasi.

\subsection*{5) Apa risiko jika pipeline CI/CD tidak ada dan deployment dilakukan manual?}
\textbf{Jawaban:} Risiko utamanya adalah \emph{drift} dan \emph{human error}. Tanpa CI, perubahan yang merusak bisa lolos tanpa terdeteksi. Tanpa CD yang terikat pada hasil CI, deployment manual mudah salah langkah: lupa rebuild, salah branch, salah konfigurasi, atau lupa menjalankan test. Akibatnya sistem yang berjalan tidak merepresentasikan kode yang seharusnya, dan debugging menjadi sulit karena tidak ada jejak verifikasi yang jelas.


\section{Ringkasan}

CI/CD adalah pendekatan otomasi yang menghubungkan perubahan kode dengan proses verifikasi dan penyebaran sistem secara konsisten. Pada tahap CI, setiap commit atau pull request memicu runner untuk melakukan \textit{checkout}, menyiapkan environment, menjalankan unit test, dan menjalankan integration test berbasis \texttt{docker compose}. Mekanisme ini mendorong deteksi dini terhadap bug, konflik dependensi, serta masalah integrasi antar layanan sehingga kualitas sistem terjaga sebelum melangkah ke tahap rilis.

Pada studi kasus TTS, arsitektur multi-service (Gateway, Web, API, Redis, Worker, MinIO) menunjukkan mengapa CI/CD penting pada sistem terdistribusi: banyak kegagalan muncul pada batas antar komponen, bukan pada fungsi tunggal. Dengan memisahkan workflow CI dan deploy melalui event \texttt{workflow\_run}, deployment hanya dilakukan saat verifikasi berhasil, dan dijalankan pada self-hosted runner yang memiliki akses langsung ke Docker di lingkungan target. Hasilnya adalah proses pengembangan yang lebih transparan, terukur, dan dapat diaudit.

