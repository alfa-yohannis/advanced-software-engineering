\chapter{Kode sebagai Infrastruktur}

\section*{Tujuan Pembelajaran}

Setelah mempelajari bab ini, capaian pembelajaran yang diharapkan adalah sebagai berikut:

\begin{enumerate}
    \item Memahami konsep \textit{Infrastructure as Code (IaC)} sebagai pendekatan deklaratif dalam pengelolaan infrastruktur, serta menjelaskan urgensinya dalam sistem modern yang bersifat terdistribusi dan multi-environment.
    
    \item Menjelaskan perbedaan peran dan ruang lingkup tanggung jawab antara Terraform dan Docker Compose dalam konteks provisioning infrastruktur dan orkestrasi container.
    
    \item Menganalisis penerapan IaC pada studi kasus TTS microservice stack untuk mendukung deployment multi-environment (development, staging, production) secara konsisten, terstruktur, dan dapat direproduksi.
\end{enumerate}



\section{Pendahuluan}

Perkembangan arsitektur perangkat lunak modern membawa perubahan signifikan dalam cara infrastruktur dikelola. Aplikasi tidak lagi berdiri sebagai satu proses tunggal pada satu server, melainkan terdiri dari banyak komponen yang saling terhubung: API service, worker asinkron, message queue, object storage, reverse proxy, serta berbagai mekanisme observability dan keamanan. Kompleksitas ini menuntut pendekatan pengelolaan infrastruktur yang sistematis, konsisten, dan dapat direproduksi.

Dalam konteks arsitektur berbasis container dan cloud-native, pengelolaan manual tidak lagi memadai. Pembuatan network secara manual, konfigurasi port melalui perintah terminal, serta pengaturan kredensial yang tersebar di berbagai tempat meningkatkan risiko kesalahan dan inkonsistensi. Selain itu, ketika aplikasi berkembang menjadi multi-environment (development, staging, production), perbedaan konfigurasi kecil dapat menyebabkan perilaku sistem yang tidak terduga.

Transisi menuju pendekatan deklaratif menjadi respons terhadap tantangan tersebut. Dalam pendekatan deklaratif, kondisi akhir infrastruktur dideskripsikan dalam bentuk kode. Sistem IaC kemudian memastikan bahwa kondisi aktual sesuai dengan deskripsi tersebut. Infrastruktur tidak lagi dikonfigurasi melalui langkah-langkah prosedural yang sulit dilacak, tetapi melalui file konfigurasi yang terstruktur, terversi, dan dapat diaudit.

Pendekatan ini tidak hanya meningkatkan konsistensi, tetapi juga memungkinkan reproducibility. Environment dapat dihancurkan dan dibangun kembali dengan konfigurasi yang identik. Eksperimen performa, pengujian integrasi, dan simulasi kegagalan dapat dilakukan secara terkontrol karena seluruh definisi infrastruktur terdokumentasi secara eksplisit.

Bab ini menggunakan TTS microservice stack sebagai studi kasus berjalan. Stack tersebut terdiri dari:
\textbf{Redis} sebagai message queue,  
\textbf{MinIO} sebagai object storage berbasis S3,  
\textbf{API service} berbasis FastAPI,  
\textbf{Web frontend} untuk interaksi pengguna,  
\textbf{Worker} service untuk proses sintesis suara (Piper),  
\textbf{Nginx gateway} sebagai reverse proxy.  

Arsitektur ini merepresentasikan pola umum sistem terdistribusi skala kecil-menengah. Terdapat komunikasi antar service melalui network internal Docker, penggunaan variabel environment untuk konfigurasi, serta kebutuhan scaling worker secara horizontal.

Melalui studi kasus ini, akan dibahas bagaimana pendekatan Infrastructure as Code -- khususnya menggunakan Terraform -- memungkinkan:
(1) Konsistensi antar environment (dev, staging, production),  
(2) Provisioning otomatis dan deklaratif,  
(3) Skalabilitas horizontal yang terkontrol,  
(4) Reproducibility untuk eksperimen dan pengujian,  
(5) Kontrol perubahan infrastruktur secara terstruktur.  

Dengan demikian, pendahuluan ini menempatkan pengelolaan infrastruktur sebagai bagian integral dari rekayasa perangkat lunak modern, bukan sekadar aktivitas operasional tambahan. Infrastruktur tidak lagi menjadi konfigurasi tersembunyi di server, melainkan artefak yang terdokumentasi dan terintegrasi dalam siklus hidup perangkat lunak.


\section{Apa itu Infrastructure as Code (IaC)?}

Infrastructure as Code (IaC) adalah pendekatan dalam rekayasa perangkat lunak yang mendefinisikan dan mengelola infrastruktur menggunakan kode, bukan konfigurasi manual. Server, network, storage, container, dan layanan lainnya tidak lagi dibuat melalui klik dashboard atau perintah ad-hoc, melainkan melalui file konfigurasi yang terversi.

Pendekatan ini menjadikan infrastruktur sebagai bagian dari siklus hidup perangkat lunak. Infrastruktur dapat ditulis, direview, diuji, dan dikelola seperti halnya source code aplikasi.

\subsection{Definisi IaC}

Secara formal, IaC dapat didefinisikan sebagai pendekatan deklaratif untuk mendeskripsikan dan memprovision infrastruktur melalui bahasa konfigurasi yang dapat diproses mesin. Dalam model ini, kondisi akhir sistem (\textit{desired state}) dideklarasikan dalam bentuk kode.

Contoh deklarasi infrastruktur dengan Terraform:

\begin{lstlisting}[language=terraform]
resource "docker_network" "net" {
  name = "tts-production"
}
\end{lstlisting}

Deklarasi tersebut menyatakan bahwa harus ada sebuah network bernama \texttt{tts-production}. Sistem IaC akan memastikan kondisi aktual sesuai dengan deskripsi tersebut.

Karakter penting dari definisi ini adalah bahwa infrastruktur diperlakukan sebagai artefak kode yang:

\begin{itemize}
\item Disimpan dalam version control
\item Direview melalui pull request
\item Memiliki riwayat perubahan
\end{itemize}

Dengan demikian, infrastruktur memiliki \textit{single source of truth} yang eksplisit dan terdokumentasi.

\subsection{Karakteristik Utama IaC}

\subsubsection*{Deklaratif vs Imperatif}

IaC modern (misalnya Terraform) menggunakan pendekatan deklaratif. Dalam pendekatan ini, konfigurasi tidak menjelaskan langkah-langkah prosedural, tetapi mendeskripsikan kondisi akhir yang diinginkan.

Pendekatan imperatif (misalnya skrip shell) akan berisi urutan perintah seperti:

\begin{lstlisting}[language=terraform]
docker network create tts-prod
docker run -d redis:7-alpine
\end{lstlisting}

Sebaliknya, pendekatan deklaratif hanya menyatakan kondisi akhir:

\begin{lstlisting}[language=terraform]
resource "docker_container" "redis" {
  image = "redis:7-alpine"
}
\end{lstlisting}

Mesin IaC yang menentukan langkah-langkah teknis untuk mencapai kondisi tersebut.

\subsubsection*{Idempotency}

Idempotency berarti menjalankan konfigurasi yang sama berkali-kali akan menghasilkan kondisi akhir yang sama tanpa efek samping tambahan.

Jika konfigurasi menyatakan bahwa harus ada 4 worker:

\begin{lstlisting}[language=terraform]
variable "worker_replicas" {
  default = 4
}
\end{lstlisting}

Menjalankan provisioning berulang kali tidak akan membuat 8 atau 12 worker. Sistem hanya akan memastikan jumlahnya tetap 4.

Idempotency sangat penting untuk menjaga konsistensi dan menghindari duplikasi resource yang tidak disengaja.

\subsubsection*{Reproducibility}

Reproducibility mengacu pada kemampuan membangun ulang environment dengan konfigurasi yang identik.

\begin{lstlisting}[language=terraform]
terraform destroy
terraform apply
\end{lstlisting}

Setelah penghancuran dan provisioning ulang, infrastruktur yang dihasilkan akan sama dengan definisi yang ada di kode. Kemampuan ini krusial untuk pengujian, disaster recovery simulation, dan eksperimen performa.

\subsubsection*{Version Control dan Auditability}

Karena infrastruktur ditulis sebagai kode, seluruh perubahan dapat dikelola melalui version control seperti Git. Hal ini memberikan:

\begin{itemize}
\item Riwayat perubahan yang dapat ditelusuri
\item Review perubahan sebelum diterapkan
\item Audit trail terhadap modifikasi infrastruktur
\end{itemize}

Dengan auditability ini, infrastruktur tidak lagi berubah tanpa jejak dokumentasi.

\subsection{Komponen dalam IaC}

\subsubsection*{Resource Definition}

Komponen pertama dalam IaC adalah definisi resource. Resource dapat berupa:

\begin{itemize}
\item Virtual Machine
\item Container
\item Network dan subnet
\item Storage bucket
\item Load balancer
\item Database
\end{itemize}

Contoh definisi resource container:

\begin{lstlisting}[language=terraform]
resource "docker_container" "api" {
  image = "session05-api:production"
}
\end{lstlisting}

Setiap resource memiliki tipe dan nama lokal, yang membentuk identitas unik dalam konfigurasi.

\subsubsection*{Dependency Graph}

IaC engine membangun dependency graph berdasarkan referensi antar resource. Jika sebuah container bergantung pada network, maka network akan dibuat terlebih dahulu.

Contoh implicit dependency:

\begin{lstlisting}[language=terraform]
resource "docker_container" "api" {
  networks_advanced {
    name = docker_network.net.name
  }
}
\end{lstlisting}

Referensi terhadap \texttt{docker\_network.net.name} membuat Terraform mengetahui bahwa network harus tersedia sebelum container dibuat.

Dependency graph memungkinkan provisioning dilakukan dalam urutan yang benar tanpa perlu mendefinisikan langkah prosedural secara eksplisit.

\subsubsection*{State Management}

State management adalah komponen penting IaC. Terraform, misalnya, menyimpan representasi kondisi aktual infrastruktur dalam file \texttt{terraform.tfstate}.

State digunakan untuk:

\begin{itemize}
\item Menghitung perbedaan antara kondisi aktual dan desired state
\item Menentukan resource mana yang perlu dibuat, diubah, atau dihapus
\item Menyimpan referensi antar resource
\end{itemize}

Tanpa state management, engine IaC tidak dapat melakukan \textit{diff} atau mendeteksi perubahan (drift detection).

\subsection*{Ringkasan}

Infrastructure as Code adalah pendekatan deklaratif untuk mendefinisikan dan mengelola infrastruktur melalui kode yang terversi. Dengan karakteristik seperti deklaratif, idempotent, reproducible, serta terintegrasi dengan version control, IaC memungkinkan infrastruktur menjadi artefak yang terstruktur, dapat diaudit, dan konsisten antar environment.

Komponen utama IaC mencakup definisi resource, dependency graph otomatis, dan manajemen state, yang bersama-sama memungkinkan provisioning dan pengelolaan infrastruktur secara deterministik dan terkontrol.

\section{Mengapa IaC Diperlukan?}

Infrastructure as Code (IaC) muncul sebagai respons terhadap kompleksitas sistem modern. Ketika aplikasi berkembang dari monolit sederhana menjadi arsitektur berbasis microservices, container, dan cloud, pengelolaan infrastruktur secara manual menjadi tidak efisien, tidak konsisten, dan sulit diaudit.

IaC memperlakukan infrastruktur sebagai artefak kode yang dapat ditulis, direview, diuji, dan dikelola seperti halnya source code aplikasi.

\subsection{Masalah Pendekatan Tradisional}

\subsubsection*{Konfigurasi Manual}

Pendekatan tradisional sering kali mengandalkan konfigurasi manual melalui dashboard cloud, SSH ke server, atau perintah ad-hoc di terminal. Praktik ini menimbulkan beberapa risiko:

\begin{itemize}
\item Kesalahan manusia (human error)
\item Inkonsistensi antar server
\item Sulitnya melacak perubahan yang dilakukan
\end{itemize}

Konfigurasi manual juga sulit direproduksi. Ketika sebuah server gagal atau perlu direplikasi, tidak selalu tersedia dokumentasi lengkap tentang langkah-langkah konfigurasi sebelumnya.

\subsubsection*{Environment Drift}

Environment drift terjadi ketika dua environment yang awalnya identik (misalnya staging dan production) perlahan-lahan menjadi berbeda karena perubahan manual yang tidak terdokumentasi.

Contoh drift:
\begin{itemize}
\item Versi library berbeda
\item Port yang diubah secara manual
\item Rule firewall atau network yang tidak sinkron
\end{itemize}

Drift meningkatkan risiko bug yang hanya muncul di production dan sulit direplikasi di staging atau development.

\subsubsection*{Konfigurasi Tidak Terdokumentasi}

Sering kali konfigurasi berada ``di kepala'' operator atau tersebar dalam catatan informal. Ketika terjadi pergantian tim atau eskalasi insiden, kurangnya dokumentasi formal memperlambat pemulihan.

Tanpa definisi infrastruktur dalam bentuk kode, tidak ada sumber kebenaran tunggal (\textit{single source of truth}) yang dapat dijadikan referensi.

\subsection{Keuntungan IaC}

\subsubsection*{Konsistensi Antar Environment}

Dengan IaC, environment didefinisikan dalam file konfigurasi yang sama. Perbedaan hanya berada pada parameter atau variabel.

Contoh pola konfigurasi:

\begin{lstlisting}[language=terraform]
module "tts" {
  env = "staging"
}
\end{lstlisting}

Pendekatan ini memastikan arsitektur tetap identik, sehingga meningkatkan environment parity dan mengurangi risiko inkonsistensi.

\subsubsection*{Otomatisasi Provisioning}

IaC memungkinkan provisioning dilakukan secara otomatis melalui satu perintah.

\begin{lstlisting}[language=terraform]
terraform apply -var-file=production.tfvars
\end{lstlisting}

Proses yang sebelumnya memerlukan konfigurasi manual berulang kini menjadi terstandarisasi dan dapat diulang tanpa variasi tak terkontrol.

\subsubsection*{Review dan Diff Perubahan}

IaC memungkinkan perubahan infrastruktur ditinjau seperti perubahan kode. Pada Terraform, perintah \texttt{plan} menampilkan diff sebelum perubahan diterapkan.

\begin{lstlisting}[language=terraform]
terraform plan -var-file=staging.tfvars
\end{lstlisting}

Mekanisme ini memberikan visibilitas terhadap dampak perubahan sebelum dieksekusi. Infrastruktur tidak lagi berubah secara diam-diam tanpa jejak audit.

\subsubsection*{Kolaborasi Berbasis Git}

Karena infrastruktur direpresentasikan sebagai kode, ia dapat dikelola melalui sistem version control seperti Git. Hal ini memungkinkan:

\begin{itemize}
\item Pull request untuk perubahan infrastruktur
\item Riwayat perubahan yang dapat ditelusuri
\item Kolaborasi tim secara terstruktur
\end{itemize}

Infrastruktur menjadi bagian dari repositori proyek, bukan konfigurasi tersembunyi di server.

\subsection{IaC dalam Konteks DevOps}

IaC merupakan pilar penting dalam praktik DevOps modern karena memungkinkan integrasi antara pengembangan aplikasi dan pengelolaan infrastruktur.

\subsubsection*{Integrasi dengan CI/CD}

Pipeline CI/CD dapat menjalankan provisioning otomatis sebelum pengujian integrasi atau deployment.

Contoh integrasi:

\begin{lstlisting}[language=terraform]
terraform init
terraform apply -var-file=dev.tfvars
pytest tests/integration
terraform destroy -var-file=dev.tfvars
\end{lstlisting}

Dengan pola ini, environment pengujian dapat dibuat secara dinamis dan dihancurkan kembali setelah selesai, memastikan reproducibility.

\subsubsection*{Infrastruktur sebagai Bagian dari Pipeline Delivery}

Dalam pendekatan tradisional, infrastruktur sering dianggap sebagai tanggung jawab terpisah dari tim pengembangan. IaC mengubah paradigma ini dengan menjadikan infrastruktur sebagai bagian dari pipeline delivery.

Setiap perubahan fitur yang memerlukan perubahan infrastruktur dapat dikemas dalam commit yang sama, diverifikasi melalui pipeline yang sama, dan dilacak dalam repositori yang sama.

\subsubsection*{Meningkatkan Reliability dan Repeatability}

Reliability meningkat karena konfigurasi infrastruktur tidak lagi bergantung pada langkah manual. Repeatability terjamin karena konfigurasi dapat dijalankan ulang pada waktu dan tempat yang berbeda dengan hasil yang konsisten.

\begin{lstlisting}[language=terraform]
terraform destroy
terraform apply
\end{lstlisting}

Kemampuan untuk membangun ulang environment secara deterministik sangat penting dalam konteks pengujian performa, disaster recovery simulation, dan eksperimen arsitektural.

\subsection*{Kesimpulan}

IaC diperlukan karena pendekatan manual tidak lagi memadai untuk sistem modern yang kompleks dan multi-environment. Dengan IaC, infrastruktur menjadi:

Terstandarisasi dan konsisten,  
Dapat direproduksi dan diaudit,  
Terintegrasi dengan pipeline CI/CD,  
Dapat dikelola secara kolaboratif melalui version control.  

Pendekatan ini meningkatkan kualitas operasional, mengurangi risiko drift, dan menjadikan infrastruktur sebagai bagian integral dari rekayasa perangkat lunak modern.

\section{Apa itu Terraform?}

Terraform adalah alat \textit{Infrastructure as Code} (IaC) yang bersifat deklaratif dan menggunakan \textit{HashiCorp Configuration Language} (HCL) untuk mendeskripsikan infrastruktur. Dengan Terraform, infrastruktur tidak lagi dikonfigurasi secara manual melalui dashboard atau perintah ad-hoc, melainkan didefinisikan sebagai kode yang terversi dan dapat direproduksi.

Terraform memungkinkan definisi infrastruktur seperti container, network, storage, VM, load balancer, dan berbagai layanan cloud lainnya dalam bentuk file \texttt{.tf}. Infrastruktur yang dihasilkan akan sesuai dengan kondisi akhir yang dideklarasikan dalam konfigurasi tersebut.

\subsection{Gambaran Umum Terraform}

Terraform bersifat deklaratif. Konfigurasi tidak menjelaskan langkah-langkah prosedural untuk mencapai suatu kondisi, tetapi langsung mendefinisikan kondisi akhir yang diinginkan.

Contoh deklarasi sederhana:

\begin{lstlisting}[language=terraform]
resource "docker_network" "net" {
  name = "tts-dev"
}
\end{lstlisting}

Deklarasi tersebut menyatakan bahwa harus ada satu network Docker bernama \texttt{tts-dev}. Terraform akan menghitung apakah network tersebut perlu dibuat, dimodifikasi, atau sudah sesuai.

Dua konsep penting dalam alur kerja Terraform adalah \texttt{plan} dan \texttt{apply}:

\begin{itemize}
\item \texttt{plan} menghasilkan rencana perubahan berdasarkan perbedaan antara konfigurasi dan state saat ini.
\item \texttt{apply} mengeksekusi rencana tersebut untuk mencapai kondisi yang diinginkan.
\end{itemize}

Dengan mekanisme ini, perubahan infrastruktur tidak terjadi secara langsung tanpa inspeksi, melainkan melalui proses yang terkontrol dan transparan.

\subsection{Konsep Kunci Terraform}

\subsubsection*{Providers}

Provider adalah plugin yang memungkinkan Terraform berinteraksi dengan sistem eksternal. Contohnya termasuk Docker, AWS, Azure, GCP, dan banyak lainnya.

Contoh deklarasi provider Docker:

\begin{lstlisting}[language=terraform]
terraform {
  required_providers {
    docker = {
      source  = "kreuzwerker/docker"
      version = "~> 3.0"
    }
  }
}
\end{lstlisting}

Provider menentukan API apa yang dapat dipanggil oleh Terraform untuk membuat atau memodifikasi resource.

\subsubsection*{Resources}

Resource adalah unit dasar infrastruktur yang dikelola Terraform. Setiap resource merepresentasikan objek nyata, seperti container, network, VM, atau bucket.

Contoh resource container:

\begin{lstlisting}[language=terraform]
resource "docker_container" "api" {
  image = "session05-api:dev"
}
\end{lstlisting}

Resource selalu memiliki tipe dan nama lokal. Kombinasi keduanya menjadi identifier unik dalam konfigurasi.

\subsubsection*{Modules}

Module adalah sekumpulan resource yang dikelompokkan untuk tujuan reuse dan abstraksi. Dengan modul, arsitektur yang sama dapat digunakan ulang untuk berbagai environment.

Contoh pemanggilan modul:

\begin{lstlisting}[language=terraform]
module "tts" {
  source = "../modules/tts_stack"
  env    = "dev"
}
\end{lstlisting}

Pendekatan modular meningkatkan konsistensi dan mengurangi duplikasi kode.

\subsubsection*{Variables dan Outputs}

Variables memungkinkan konfigurasi menjadi fleksibel dan dapat disesuaikan antar environment.

\begin{lstlisting}[language=terraform]
variable "worker_replicas" {
  type    = number
  default = 1
}
\end{lstlisting}

Outputs digunakan untuk mengekspose informasi setelah provisioning, misalnya URL layanan.

\begin{lstlisting}[language=terraform]
output "gateway_url" {
  value = "http://localhost:8088"
}
\end{lstlisting}

Variables dan outputs membentuk kontrak antara modul dan root module.

\subsubsection*{State File}

Terraform menyimpan representasi kondisi aktual infrastruktur dalam \texttt{terraform.tfstate}. File ini menjadi referensi untuk menghitung perubahan pada perintah \texttt{plan}.

State file memungkinkan:

\begin{itemize}
\item Deteksi perubahan (drift detection)
\item Perhitungan diff sebelum eksekusi
\item Referensi antar resource
\end{itemize}

Tanpa state file, Terraform tidak dapat menentukan perubahan apa yang diperlukan.

\subsection{Eksekusi Terraform}

Terraform dijalankan melalui serangkaian perintah CLI.

\subsubsection*{\texttt{terraform init}}

Perintah ini menginisialisasi direktori kerja, mengunduh provider yang diperlukan, dan menyiapkan backend state.

\begin{lstlisting}[language=terraform]
terraform init
\end{lstlisting}

\subsubsection*{\texttt{terraform plan}}

Perintah ini menganalisis konfigurasi dan state saat ini untuk menghasilkan rencana perubahan.

\begin{lstlisting}[language=terraform]
terraform plan -var-file=dev.tfvars
\end{lstlisting}

Output dari \texttt{plan} menunjukkan resource yang akan dibuat, diubah, atau dihapus.

\subsubsection*{\texttt{terraform apply}}

Perintah ini mengeksekusi rencana perubahan yang telah dihitung.

\begin{lstlisting}[language=terraform]
terraform apply -var-file=dev.tfvars
\end{lstlisting}

Setelah \texttt{apply}, state file akan diperbarui agar mencerminkan kondisi aktual infrastruktur.

\subsubsection*{\texttt{terraform destroy}}

Perintah ini menghancurkan seluruh resource yang dikelola oleh konfigurasi saat ini.

\begin{lstlisting}[language=terraform]
terraform destroy -var-file=dev.tfvars
\end{lstlisting}

Kemampuan untuk menghancurkan dan membangun ulang infrastruktur secara konsisten merupakan fondasi reproducibility dan eksperimen terkontrol.

\subsection*{Kesimpulan}

Terraform adalah alat IaC deklaratif berbasis HCL yang memungkinkan definisi, provisioning, dan manajemen infrastruktur secara terstruktur. Dengan konsep provider, resource, module, variable, output, dan state file, Terraform menyediakan mekanisme pengelolaan infrastruktur yang dapat direproduksi, diaudit, dan diskalakan secara konsisten di berbagai environment.


\section{Apa yang Membuat Terraform Berbeda dari Docker Compose?}

Terraform dan Docker Compose sama-sama dapat digunakan untuk menjalankan aplikasi berbasis container. Namun keduanya berada pada level abstraksi dan ruang lingkup tanggung jawab yang berbeda. Docker Compose berfokus pada orkestrasi container di dalam satu host Docker, sedangkan Terraform beroperasi pada level infrastruktur yang lebih luas melalui pendekatan \textit{Infrastructure as Code}.

Perbedaan ini menjadi penting ketika sistem berkembang dari sekadar eksperimen lokal menjadi arsitektur multi-environment yang membutuhkan reproducibility, skalabilitas, dan kontrol perubahan terstruktur.

\subsection{Level Abstraksi}

Docker Compose bekerja pada level container runtime. File \texttt{docker-compose.yml} mendeskripsikan service, network, dan volume yang akan dijalankan di atas Docker Engine yang sudah tersedia. Fokusnya adalah menjalankan sekumpulan container sebagai satu aplikasi.

Contoh deklarasi sederhana di Compose:

\begin{lstlisting}[language=terraform]
services:
  api:
    build: ./services/api
    ports:
      - "8000:8000"
\end{lstlisting}

Sebaliknya, Terraform bekerja pada level infrastruktur. Provider yang digunakan bisa berupa Docker, cloud provider (AWS, Azure, GCP), atau bahkan sistem DNS dan IAM. Terraform tidak hanya membuat container, tetapi juga dapat membuat network, storage, load balancer, hingga VM atau cluster Kubernetes.

Contoh deklarasi resource Docker dalam Terraform:

\begin{lstlisting}[language=terraform]
resource "docker_container" "api" {
  image = docker_image.api.name
  ports {
    internal = 8000
    external = 8000
  }
}
\end{lstlisting}

Pada level abstraksi, Compose mengelola proses container, sedangkan Terraform mengelola sistem yang lebih luas tempat container tersebut berjalan.

\subsection{Scope Tanggung Jawab}

Docker Compose bertanggung jawab pada orkestrasi lokal. Ia memastikan service dapat dijalankan bersama, saling terhubung melalui network internal, serta berbagi volume jika diperlukan. Scope ini umumnya terbatas pada satu host.

Terraform memiliki scope yang lebih luas. Dengan provider yang sesuai, Terraform dapat memprovision:

VM atau compute instance,  
Virtual network dan subnet,  
Load balancer,  
DNS record,  
IAM role dan policy,  
Object storage dan database terkelola.  

Dengan demikian, Terraform dapat mengelola seluruh fondasi infrastruktur, sedangkan Compose hanya mengelola aplikasi yang berjalan di atas fondasi tersebut.

\subsection{State dan Drift Detection}

Salah satu perbedaan mendasar adalah keberadaan \textit{state file} pada Terraform. Terraform menyimpan representasi kondisi aktual infrastruktur dalam file state. Setiap perubahan pada konfigurasi akan dibandingkan dengan state tersebut untuk menghasilkan rencana perubahan (\texttt{plan}).

Jika terjadi perubahan di luar Terraform (misalnya container dihapus manual), Terraform dapat mendeteksi perbedaan antara state dan realitas sistem saat menjalankan \texttt{plan} atau \texttt{apply}. Mekanisme ini disebut \textit{drift detection}.

Docker Compose tidak memiliki konsep state global yang tersimpan secara eksplisit. Compose dapat menjalankan ulang konfigurasi, tetapi tidak menyimpan model deklaratif jangka panjang yang digunakan untuk menghitung diff terhadap kondisi aktual sistem.

\subsection{Multi-Environment Management}

Pengelolaan multi-environment pada Compose biasanya dilakukan dengan file override seperti:

\begin{lstlisting}[language=terraform]
docker-compose.yml
docker-compose.override.yml
docker-compose.prod.yml
\end{lstlisting}

Atau melalui environment variable. Pendekatan ini efektif untuk skala kecil, tetapi dapat menjadi kompleks ketika jumlah environment meningkat.

Terraform mendukung pendekatan modular dan berbasis variabel. Satu modul infrastruktur dapat digunakan ulang untuk dev, staging, dan production. Perbedaan hanya terletak pada nilai variabel dan file \texttt{*.tfvars}.

Contoh pemanggilan modul untuk environment berbeda:

\begin{lstlisting}[language=terraform]
module "tts" {
  source = "../modules/tts_stack"
  env    = "production"
}
\end{lstlisting}

Pendekatan ini menjaga struktur arsitektur tetap identik antar environment, sehingga meningkatkan environment parity dan mengurangi risiko inkonsistensi konfigurasi.

\subsection{Production-Grade Capabilities}

Docker Compose dirancang terutama untuk development dan single-host deployment. Meskipun dapat digunakan dalam konteks produksi sederhana, Compose tidak menyediakan mekanisme provisioning infrastruktur cloud, manajemen IAM, atau integrasi dengan layanan terkelola.

Terraform dirancang untuk konteks production-grade. Ia dapat:

Membuat cluster Kubernetes di cloud,  
Mengonfigurasi load balancer dan auto-scaling group,  
Mengelola object storage dan database terkelola,  
Mengatur IAM dan kebijakan keamanan,  
Mendefinisikan infrastruktur lintas region dan lintas akun.  

Dengan demikian, Terraform cocok untuk skenario enterprise dan arsitektur terdistribusi yang kompleks. Docker Compose tetap relevan untuk pengembangan lokal, eksperimen, dan orkestrasi ringan pada satu host.

\subsection*{Kesimpulan}

Perbedaan utama dapat diringkas sebagai berikut: Docker Compose berfokus pada orkestrasi container dalam satu host yang sudah ada, sedangkan Terraform berfokus pada provisioning dan manajemen infrastruktur secara deklaratif dan terstruktur.

Dalam konteks arsitektur TTS, Docker Compose cocok untuk prototyping cepat di development, sedangkan Terraform memberikan reproducibility, multi-environment management, scaling terkontrol, dan fondasi yang lebih siap untuk produksi.


\section{Deskripsi Studi Kasus: TTS Microservice Stack}

\subsection{Arsitektur Sistem}

Studi kasus dalam bab ini menggunakan sebuah sistem \textit{Text-to-Speech (TTS)} berbasis arsitektur \textit{microservices}. Sistem ini dirancang untuk menerima teks dari pengguna, memprosesnya menjadi suara, menyimpannya dalam bentuk berkas audio, dan menyediakan akses unduhan melalui endpoint HTTP. Arsitektur yang digunakan bersifat terdistribusi dan memisahkan tanggung jawab setiap komponen agar sistem dapat diskalakan dan dikelola secara fleksibel pada berbagai environment.

Komponen pertama adalah \textit{API service} yang dibangun menggunakan FastAPI. Layanan ini bertindak sebagai pintu masuk sistem (\textit{entry point}) dan menerima permintaan dari klien melalui protokol HTTP. API melakukan validasi terhadap input teks, menghasilkan identitas pekerjaan, dan memasukkan permintaan tersebut ke dalam antrian pesan. Selain itu, API juga menyediakan endpoint untuk \textit{health check} dan observabilitas, sehingga memudahkan pemantauan kondisi sistem dalam deployment multi-environment.

Proses komputasi utama dilakukan oleh \textit{worker service}. Worker bertanggung jawab mengambil pesan dari antrian, menjalankan proses sintesis suara menggunakan model TTS (misalnya model berbasis Piper), kemudian menghasilkan berkas audio dalam format MP3. Setelah proses sintesis selesai, berkas hasil akan diunggah ke sistem penyimpanan objek. Karena worker terpisah dari API, jumlahnya dapat ditambah atau dikurangi sesuai kebutuhan beban sistem tanpa memengaruhi komponen lain.

Redis digunakan sebagai \textit{message broker} atau antrian pekerjaan. Penggunaan Redis memungkinkan terjadinya pemisahan (decoupling) antara lapisan penerimaan permintaan dan lapisan komputasi berat. Dengan pendekatan ini, API tetap responsif meskipun proses sintesis membutuhkan waktu relatif lama. Redis juga memungkinkan implementasi skalabilitas horizontal dengan menambahkan lebih banyak worker yang mengonsumsi antrian yang sama.

Penyimpanan berkas audio dilakukan menggunakan MinIO sebagai \textit{object storage}. MinIO dipilih karena kompatibel dengan API S3, sehingga sistem dapat dengan mudah dimigrasikan ke layanan penyimpanan terkelola di cloud jika diperlukan. Setiap environment—seperti dev, staging, dan production—dapat menggunakan bucket yang berbeda untuk menjaga isolasi data dan meminimalkan risiko pencampuran artefak antar environment.

Sebagai lapisan terluar, sistem menggunakan Nginx sebagai \textit{gateway} atau \textit{reverse proxy}. Komponen ini bertugas mengarahkan lalu lintas dari klien ke layanan internal yang sesuai. Dalam skenario production, gateway juga dapat menangani terminasi TLS, pembatasan akses, serta kebijakan keamanan tambahan lainnya.

Secara keseluruhan, arsitektur TTS ini memisahkan komputasi, penyimpanan, dan akses jaringan menjadi komponen independen. Pola ini mencerminkan praktik arsitektur sistem modern yang mendukung skalabilitas, isolasi tanggung jawab, dan kemudahan pengelolaan lintas environment. Struktur inilah yang kemudian menjadi dasar untuk membandingkan penggunaan Docker Compose pada tahap awal pengembangan dengan pendekatan Infrastructure as Code menggunakan Terraform dalam pengelolaan deployment multi-environment.


\subsection{Struktur Proyek}

Struktur proyek pada studi kasus ini dirancang untuk memisahkan dengan jelas antara kode aplikasi, konfigurasi orkestrasi container, dan konfigurasi Infrastructure as Code. Pemisahan ini bertujuan agar setiap lapisan sistem—aplikasi, deployment lokal, dan provisioning environment—dapat berkembang secara independen namun tetap terintegrasi secara konsisten.

Direktori \texttt{app} berisi seluruh komponen aplikasi TTS. Di dalamnya terdapat subdirektori \texttt{services} yang memisahkan implementasi API, web frontend, dan worker sebagai unit layanan yang berbeda. Setiap service memiliki \texttt{Dockerfile} dan \texttt{requirements.txt} masing-masing, sehingga dapat dibangun sebagai image container yang terpisah. Struktur ini mencerminkan arsitektur microservices yang memungkinkan pengembangan, pengujian, dan scaling dilakukan secara independen pada tiap komponen.

Direktori \texttt{models} menyimpan model TTS yang digunakan oleh worker. Pemisahan model dari kode aplikasi memberikan fleksibilitas dalam pengelolaan artefak komputasi berat, termasuk kemungkinan untuk mengganti model tanpa mengubah struktur utama sistem. Sementara itu, direktori \texttt{client} berisi utilitas seperti \texttt{load\_client.py} yang digunakan untuk pengujian beban atau simulasi permintaan ke API.

Direktori \texttt{tests} mengorganisasi pengujian menjadi dua kategori utama, yaitu \textit{unit tests} dan \textit{integration tests}. Pendekatan ini mendukung praktik CI/CD yang memastikan setiap perubahan kode dapat diverifikasi baik secara komponen individual maupun secara end-to-end terhadap keseluruhan sistem.

Direktori \texttt{compose} memuat berkas \texttt{docker-compose.yml} yang digunakan untuk menjalankan seluruh stack pada satu host. Berkas ini merepresentasikan tahap awal deployment, di mana fokus utama adalah orkestrasi container untuk kebutuhan pengembangan dan eksperimen.

Selanjutnya, direktori \texttt{iac/terraform} memisahkan konfigurasi Infrastructure as Code dari kode aplikasi. Di dalamnya terdapat struktur environment seperti \texttt{dev}, \texttt{staging}, dan \texttt{prod}, masing-masing memiliki \texttt{main.tf} dan berkas variabel tersendiri. Pendekatan ini memungkinkan setiap environment menggunakan module yang sama tetapi dengan parameter berbeda, sehingga konsistensi arsitektur tetap terjaga. Subdirektori \texttt{modules/tts\_stack} merepresentasikan abstraksi deployment utama yang dapat digunakan ulang lintas environment.

Dengan struktur proyek seperti ini, batas antara kode aplikasi, orkestrasi container, dan definisi infrastruktur menjadi jelas. Pemisahan tersebut mendukung praktik DevOps modern, di mana aplikasi dan infrastruktur dikelola sebagai artefak yang terpisah namun tetap terdokumentasi dan terversi secara konsisten dalam satu repositori.


\begin{lstlisting}[language=bash, caption={Struktur proyek menggunakan Terraform}]
.
|- app
|  |- client
|  |  |- load_client.py
|  |- gateway
|  |  |- nginx.conf
|  |- models
|  |  |- en_GB-alan-medium.onnx
|  |  |- en_GB-alan-medium.onnx.json
|  |- pytest.ini
|  |- requirements-dev.txt
|  |- services
|  |  |- api
|  |  |  |- api.py
|  |  |  |- Dockerfile
|  |  |  |- requirements.txt
|  |  |- web
|  |  |  |- Dockerfile
|  |  |  |- requirements.txt
|  |  |  |- static
|  |  |  |- web.py
|  |  |- worker
|  |     |- Dockerfile
|  |     |- requirements.txt
|  |     |- worker.py
|  |- tests
|     |- conftest.py
|     |- integration
|     |  |- test_e2e.py
|     |- unit
|        |- api
|        |- web
|        |- worker
|- compose
|  |- docker-compose.yml
|- iac
   |- terraform
      |- dev
      |  |- dev.tfvars
      |  |- main.tf
      |- modules
      |  |- tts_stack
      |	    |- main.tf
      |	    |- outputs.tf
      |	    |- variables.tf
      |- prod
      |  |- main.tf
      |  |- production.tfvars
      |- staging
         |- main.tf
         |- staging.tfvars
\end{lstlisting}

\subsection{\texttt{main.tf}, \texttt{outputs.tf}, dan \texttt{variables.tf} dalam \texttt{modules/tts\_stack}}

Modul \texttt{tts\_stack} mengenkapsulasi seluruh resource Docker untuk satu environment (\texttt{dev}/\texttt{staging}/\texttt{prod}). Intinya: penamaan resource dibuat unik per environment, DNS internal stabil melalui network alias, port host dibedakan dari \texttt{*.tfvars}, dan worker dapat diskalakan lewat \texttt{count}.

\subsubsection{Struktur Modul}

\begin{lstlisting}[language=terraform]
modules/tts_stack/
  main.tf
  variables.tf
  outputs.tf
\end{lstlisting}

\subsubsection{\texttt{variables.tf}: Kontrak Input Modul}

\texttt{env} dipakai untuk suffix penamaan resource (mis.\ \texttt{tts-dev-*}), sedangkan \texttt{project\_root} memastikan path build context bersifat absolut/stabil.

\begin{lstlisting}[language=terraform]
variable "env"          { type = string }
variable "project_root" { type = string }
\end{lstlisting}

Port host dikemas sebagai \texttt{object} supaya per-environment cukup beda di \texttt{*.tfvars} tanpa menyentuh modul.

\begin{lstlisting}[language=terraform]
variable "ports" {
  type = object({
    redis         = number
    minio_api     = number
    minio_console = number
    api           = number
    web           = number
    gateway       = number
  })
}
\end{lstlisting}

Skalabilitas worker dan opsi mount folder model disediakan sebagai variabel terpisah.

\begin{lstlisting}[language=terraform]
variable "worker_replicas" { type = number, default = 1 }
variable "mount_models"    { type = bool,   default = false }
\end{lstlisting}

\subsubsection{\texttt{main.tf}: Implementasi Resource}

Bagian \texttt{locals} merangkum prefix penamaan dan endpoint internal. Prefix berbasis \texttt{env} mencegah konflik container saat beberapa environment berjalan di host yang sama.

\begin{lstlisting}[language=terraform]
locals {
  prefix    = "tts-${var.env}"
  redis_url = "redis://redis:6379/0"
  api_base  = "http://api:8000"
}
\end{lstlisting}

Network dibuat per environment agar isolasi layanan terjaga. Volume MinIO juga dibuat per environment agar data tidak tercampur.

\begin{lstlisting}[language=terraform]
resource "docker_network" "net" { name = local.prefix }

resource "docker_volume" "minio_data" {
  name = "minio_data_${var.env}"
}
\end{lstlisting}

Image dibangun dan ditag per environment sehingga \texttt{dev/staging/prod} bisa coexist.

\begin{lstlisting}[language=terraform]
resource "docker_image" "api" {
  name = "session05-api:${var.env}"
  build { context = "${var.project_root}/app/services/api" }
}
\end{lstlisting}

Service discovery dibuat stabil dengan network alias, misalnya \texttt{aliases = ["api"]}. Dengan ini, komponen lain selalu memanggil \texttt{http://api:8000} di network internal, walaupun nama container sebenarnya \texttt{tts-dev-api} atau \texttt{tts-prod-api}.

\begin{lstlisting}[language=terraform]
resource "docker_container" "api" {
  name  = "${local.prefix}-api"
  image = docker_image.api.name

  networks_advanced {
    name    = docker_network.net.name
    aliases = ["api"]
  }
}
\end{lstlisting}

Worker diskalakan melalui \texttt{count}. Saat \texttt{worker\_replicas = 3}, Terraform akan menghasilkan \texttt{tts-dev-worker-0}, \texttt{tts-dev-worker-1}, dan \texttt{tts-dev-worker-2}.

\begin{lstlisting}[language=terraform]
resource "docker_container" "worker" {
  count = var.worker_replicas
  name  = "${local.prefix}-worker-${count.index}"
  image = docker_image.worker.name
}
\end{lstlisting}

Mount folder \texttt{/models} dibuat kondisional menggunakan \texttt{dynamic "volumes"}, sehingga environment tertentu (mis.\ \texttt{prod}) bisa memakai model host, sementara \texttt{dev} tidak perlu.

\begin{lstlisting}[language=terraform]
dynamic "volumes" {
  for_each = var.mount_models ? [1] : []
  content {
    host_path      = "${var.project_root}/app/models"
    container_path = "/models"
    read_only      = true
  }
}
\end{lstlisting}

\subsubsection{\texttt{outputs.tf}: Informasi Setelah Apply}

Output diekspos agar endpoint layanan langsung terlihat setelah \texttt{terraform apply}, tanpa inspeksi manual ke Docker.

\begin{lstlisting}[language=terraform]
output "urls" {
  value = {
    gateway = "http://localhost:${var.ports.gateway}"
    web     = "http://localhost:${var.ports.web}"
    api     = "http://localhost:${var.ports.api}"
    minio   = "http://localhost:${var.ports.minio_console}"
  }
}
\end{lstlisting}

\subsubsection{Pemanggilan Modul dari Root Module}

Root module di \texttt{dev/staging/prod} cukup memanggil modul yang sama dan mengirim variabel. Perbedaan environment umumnya hanya pada \texttt{env}, \texttt{ports}, serta \texttt{worker\_replicas}/\texttt{mount\_models}.

\begin{lstlisting}[language=terraform]
module "tts_stack" {
  source       = "../../modules/tts_stack"
  env          = var.env
  project_root = var.project_root
  ports        = var.ports

  worker_replicas = var.worker_replicas
  mount_models    = var.mount_models
}
\end{lstlisting}

\subsection{\texttt{main.tf} dan \texttt{dev.tfvars} dalam \texttt{dev}}

Folder \texttt{dev} berperan sebagai \textit{root module} untuk environment development. Di sini kita tidak mendefinisikan resource Docker secara langsung, melainkan \textbf{memanggil modul} \texttt{modules/tts\_stack} dan mengisi variabel-variabelnya dengan nilai khusus environment dev. Konsekuensinya, perubahan environment (mis.\ pindah ke \texttt{staging}) cukup dilakukan lewat file \texttt{*.tfvars} dan/atau folder environment lain, tanpa mengubah isi modul.

\subsubsection{\texttt{main.tf}: Root Module yang Memanggil \texttt{modules/tts\_stack}}

Bagian awal biasanya mendefinisikan variabel yang akan diisi dari \texttt{dev.tfvars}. Dua variabel yang paling penting untuk studi kasus ini adalah \texttt{mp3\_bucket} (nama bucket MinIO untuk output MP3) dan \texttt{internal\_token} (token otorisasi internal antarkomponen API--worker).

\begin{lstlisting}[language=terraform]
variable "mp3_bucket"     { type = string }
variable "internal_token" { type = string }
\end{lstlisting}

Agar worker bisa diskalakan, \texttt{worker\_replicas} disediakan sebagai variabel numerik. Opsi \texttt{mount\_models} dipakai untuk menentukan apakah folder model ONNX di host akan dimount read-only ke container worker (berguna saat model disimpan di host dan ingin dipakai lintas container tanpa rebuild image).

\begin{lstlisting}[language=terraform]
variable "worker_replicas" {
  type    = number
  default = 1
}

variable "mount_models" {
  type    = bool
  default = false
}
\end{lstlisting}

Inti \texttt{main.tf} adalah pemanggilan modul \texttt{tts}. Parameter \texttt{env = "dev"} membuat semua resource akan diprefix \texttt{tts-dev-*}. Parameter \texttt{project\_root} dihitung dengan \texttt{abspath(...)} agar selalu menjadi path absolut ke root proyek, sehingga build context Docker (API/Web/Worker) dan file mount (\texttt{nginx.conf}, \texttt{models/}) dapat ditemukan secara konsisten terlepas dari lokasi eksekusi Terraform.

\begin{lstlisting}[language=terraform]
module "tts" {
  source = "../modules/tts_stack"

  env          = "dev"
  project_root = abspath("${path.module}/../../..")
}
\end{lstlisting}

Blok \texttt{ports} menentukan pemetaan port host-side untuk dev. Karena ini environment dev, port yang dipilih biasanya ``default'' dan mudah diingat (Redis 6379, MinIO 9000/9001, API 8000, Web 8080, Gateway 8088). Inilah mekanisme utama agar beberapa environment dapat coexist: environment lain cukup memakai port host yang berbeda.

\begin{lstlisting}[language=terraform]
ports = {
  redis         = 6379
  minio_api     = 9000
  minio_console = 9001
  api           = 8000
  web           = 8080
  gateway       = 8088
}
\end{lstlisting}

Kemudian, \texttt{mp3\_bucket} dan \texttt{internal\_token} diteruskan dari variabel root module (\texttt{var.*}) sehingga nilainya bisa dikontrol dari \texttt{dev.tfvars}. Pola ini penting karena token dan nama bucket biasanya berbeda antar environment.

\begin{lstlisting}[language=terraform]
mp3_bucket     = var.mp3_bucket
internal_token = var.internal_token
\end{lstlisting}

Kredensial MinIO dituliskan eksplisit agar perilakunya identik dengan \texttt{docker-compose.yml} (sering kali \texttt{minioadmin/minioadmin} di dev). Walaupun modul sudah punya default, menuliskan eksplisit di root module membantu pembaca (mahasiswa) melihat bahwa nilai ini adalah bagian dari konfigurasi environment.

\begin{lstlisting}[language=terraform]
minio_root_user     = "minioadmin"
minio_root_password = "minioadmin"
\end{lstlisting}

Konfigurasi Piper diisi sesuai lokasi file config di dalam container (\texttt{/models/...json}) dan parameter \texttt{length\_scale}. Di dev, nilainya biasanya default untuk menjaga eksperimen mudah direproduksi.

\begin{lstlisting}[language=terraform]
piper_model_config_path = "/models/en_GB-alan-medium.onnx.json"
piper_length_scale      = "1.0"
\end{lstlisting}

Terakhir, parameter untuk scaling dan mount model diteruskan dari variabel root module agar dapat dioverride lewat \texttt{dev.tfvars} tanpa menyentuh kode.

\begin{lstlisting}[language=terraform]
worker_replicas = var.worker_replicas
mount_models    = var.mount_models
\end{lstlisting}

Setelah modul dipanggil, \texttt{output} di root module biasanya hanya meneruskan output dari modul untuk memudahkan akses URL.

\begin{lstlisting}[language=terraform]
output "urls" {
  value = module.tts.urls
}
\end{lstlisting}

\subsubsection{\texttt{dev.tfvars}: Nilai Spesifik Environment Dev}

File \texttt{dev.tfvars} menyimpan nilai variabel untuk environment dev. Ini memisahkan \textit{konfigurasi} dari \textit{kode}, sehingga \texttt{main.tf} tetap generik dan bersih.

\begin{lstlisting}[language=terraform]
mp3_bucket     = "tts-dev"
internal_token = "changeme-dev"

worker_replicas = 1
mount_models    = false
\end{lstlisting}

Dengan konfigurasi ini, output audio akan masuk ke bucket \texttt{tts-dev}, komunikasi internal memakai token \texttt{changeme-dev}, worker hanya 1 replika (cukup untuk pengujian dasar), dan worker tidak me-mount model dari host (artinya model harus sudah tersedia sesuai strategi build/runtime yang dipakai di image worker).

\subsubsection{Cara Menjalankan Environment Dev}

Praktik yang umum adalah menjalankan Terraform dari folder \texttt{dev} sambil menunjuk \texttt{dev.tfvars}, sehingga root module membaca nilai-nilai environment dev dan menerapkan resource Docker via provider \texttt{kreuzwerker/docker}.

\begin{lstlisting}[language=terraform]
# dijalankan dari iac/terraform/dev
terraform init
terraform apply -var-file=dev.tfvars
\end{lstlisting}

Setelah \texttt{apply} selesai, \texttt{module.tts.urls.gateway} (melalui output \texttt{urls}) dapat dipakai untuk mengakses layanan melalui Nginx gateway pada \texttt{http://localhost:8088}.

\subsection{\texttt{main.tf} dan \texttt{staging.tfvars} dalam \texttt{staging}}

Folder \texttt{staging} adalah root module untuk environment staging. Polanya sama seperti \texttt{dev}: root module tidak menuliskan resource Docker satu per satu, melainkan memanggil modul \texttt{modules/tts\_stack} dan mengisi variabelnya dengan nilai yang khas untuk staging. Perbedaan staging dibanding dev terutama pada (i) nilai konfigurasi (\texttt{mp3\_bucket}, \texttt{internal\_token}), (ii) \textbf{port host yang digeser} agar tidak bentrok dengan dev, serta (iii) skala worker dan strategi runtime model.

\subsubsection{\texttt{main.tf}: Root Module untuk Staging}

Di staging, \texttt{mp3\_bucket} dan \texttt{internal\_token} tetap didefinisikan sebagai variabel root module supaya nilainya dapat dipasok dari \texttt{staging.tfvars}. Ini membuat \texttt{main.tf} bersih dan reusable.

\begin{lstlisting}[language=terraform]
variable "mp3_bucket"     { type = string }
variable "internal_token" { type = string }
\end{lstlisting}

Berbeda dari dev, default \texttt{worker\_replicas} diset ke 2 dan \texttt{mount\_models} menjadi \texttt{true}. Pilihan ini umum pada staging: kita ingin menguji perilaku sistem saat ada lebih dari satu worker, serta memastikan runtime memakai folder model yang dimount dari host (lebih cepat untuk iterasi model tanpa rebuild image).

\begin{lstlisting}[language=terraform]
variable "worker_replicas" {
  type    = number
  default = 2
}

variable "mount_models" {
  type    = bool
  default = true
}
\end{lstlisting}

Pemanggilan modul dilakukan melalui \texttt{module "tts"}. Parameter \texttt{env = "staging"} akan mempengaruhi prefix penamaan resource (\texttt{tts-staging-*}) dan nama network (\texttt{tts-staging}). Parameter \texttt{project\_root} memakai \texttt{abspath(...)} agar build context Docker (API/Web/Worker) dan path mount (nginx.conf, models) dapat di-resolve dengan benar.

\begin{lstlisting}[language=terraform]
module "tts" {
  source       = "../modules/tts_stack"
  env          = "staging"
  project_root = abspath("${path.module}/../../..")
}
\end{lstlisting}

Bagian paling penting untuk coexistence adalah \texttt{ports}. Di staging, seluruh port host digeser (mis.\ Redis menjadi 16379, API menjadi 18000, gateway menjadi 18088) supaya tidak ada collision dengan port dev yang biasanya menggunakan angka ``default''.

\begin{lstlisting}[language=terraform]
ports = {
  redis         = 16379
  minio_api     = 19000
  minio_console = 19001
  api           = 18000
  web           = 18080
  gateway       = 18088
}
\end{lstlisting}

Nilai \texttt{mp3\_bucket} dan \texttt{internal\_token} diteruskan dari variabel root module. Dengan ini, staging dapat memakai bucket berbeda (\texttt{tts-staging}) dan token berbeda (\texttt{changeme-staging}) tanpa mengubah modul.

\begin{lstlisting}[language=terraform]
mp3_bucket     = var.mp3_bucket
internal_token = var.internal_token
\end{lstlisting}

Kredensial MinIO ditulis eksplisit agar konsisten dengan Compose (dan agar pembaca tidak perlu menebak apakah modul memakai default). Walaupun staging sering dianggap lebih ``serius'', untuk lab/kelas biasanya tetap memakai kredensial dev-default.

\begin{lstlisting}[language=terraform]
minio_root_user     = "minioadmin"
minio_root_password = "minioadmin"
\end{lstlisting}

Konfigurasi Piper tetap mengarah ke file config di \texttt{/models}. Karena \texttt{mount\_models = true}, folder \texttt{app/models} di host akan dimount ke \texttt{/models} di container worker. Artinya, file \texttt{en\_GB-alan-medium.onnx.json} harus benar-benar ada di host pada path proyek.

\begin{lstlisting}[language=terraform]
piper_model_config_path = "/models/en_GB-alan-medium.onnx.json"
piper_length_scale      = "1.0"
\end{lstlisting}

Terakhir, skala worker dan mount model diteruskan ke modul dari variabel root module. Untuk staging, kombinasi default-nya adalah 2 replika worker dan mount model aktif.

\begin{lstlisting}[language=terraform]
worker_replicas = var.worker_replicas
mount_models    = var.mount_models
\end{lstlisting}

Output di root module meneruskan \texttt{module.tts.urls} agar setelah \texttt{apply} kita langsung mendapatkan endpoint yang bisa diakses dari host, termasuk gateway staging di port 18088.

\begin{lstlisting}[language=terraform]
output "urls" {
  value = module.tts.urls
}
\end{lstlisting}

\subsubsection{\texttt{staging.tfvars}: Nilai Konfigurasi untuk Staging}

File \texttt{staging.tfvars} memuat nilai variabel khusus staging. Bucket dipisahkan dari dev agar artefak (MP3) tidak tercampur, token dibedakan agar trafik antar environment tidak saling ``terpercaya'' secara tidak sengaja, dan worker dinaikkan menjadi 2 untuk menguji concurrency.

\begin{lstlisting}[language=terraform]
mp3_bucket     = "tts-staging"
internal_token = "changeme-staging"

worker_replicas = 2
mount_models    = true
\end{lstlisting}

Karena \texttt{mount\_models = true}, staging cocok untuk eksperimen ``ganti model cepat'': cukup mengganti file ONNX/JSON di folder \texttt{app/models} pada host, lalu restart worker (atau \texttt{terraform apply} bila diperlukan) tanpa rebuild image.

\subsubsection{Cara Menjalankan Environment Staging}

Terraform dijalankan dari folder \texttt{staging} menggunakan file var khusus staging.

\begin{lstlisting}[language=terraform]
# dijalankan dari iac/terraform/staging
terraform init
terraform apply -var-file=staging.tfvars
\end{lstlisting}

Setelah \texttt{apply} selesai, gateway staging dapat diakses melalui \texttt{http://localhost:18088}. Karena port sudah digeser, dev dan staging dapat berjalan bersamaan dalam satu host tanpa tabrakan port, sementara komunikasi internal setiap environment tetap terisolasi oleh network Docker yang berbeda (\texttt{tts-dev} vs \texttt{tts-staging}).


\subsection{\texttt{main.tf} dan \texttt{production.tfvars} dalam \texttt{prod}}

Folder \texttt{prod} adalah root module untuk environment production. Seperti \texttt{dev} dan \texttt{staging}, ia hanya memanggil modul \texttt{modules/tts\_stack}, tetapi nilai konfigurasinya dibuat lebih ketat: port host didedikasikan agar tidak bentrok dengan environment lain, jumlah worker dinaikkan untuk concurrency yang lebih tinggi, dan kredensial sensitif (token internal dan password MinIO) diperlakukan sebagai \texttt{sensitive} serta \textbf{tidak ditulis hardcode di \texttt{main.tf}}.

\subsubsection{\texttt{main.tf}: Root Module untuk Production}

Dua variabel dasar, \texttt{mp3\_bucket} dan \texttt{internal\_token}, tetap didefinisikan sebagai input root module. Bedanya, \texttt{internal\_token} diberi atribut \texttt{sensitive = true} agar tidak mudah tercetak pada output/log Terraform.

\begin{lstlisting}[language=terraform]
variable "mp3_bucket" { type = string }

variable "internal_token" {
  type      = string
  sensitive = true
}
\end{lstlisting}

Produksi menaikkan concurrency dengan default \texttt{worker\_replicas = 4}. Di sisi lain, \texttt{mount\_models} umumnya \texttt{false} karena model sebaiknya dibundel (baked) ke image worker demi konsistensi deploy dan menghindari ketergantungan ke filesystem host.

\begin{lstlisting}[language=terraform]
variable "worker_replicas" {
  type    = number
  default = 4
}

variable "mount_models" {
  type    = bool
  default = false
}
\end{lstlisting}

Kredensial MinIO dibuat sebagai variabel terpisah dan juga ditandai \texttt{sensitive}. Praktiknya, nilai ini diisi melalui \texttt{production.tfvars} (atau lewat mekanisme secret management di CI/CD), bukan disisipkan langsung di kode.

\begin{lstlisting}[language=terraform]
variable "minio_root_user" {
  type      = string
  sensitive = true
}

variable "minio_root_password" {
  type      = string
  sensitive = true
}
\end{lstlisting}

Pemanggilan modul menggunakan \texttt{env = "production"} yang akan memprefix resource menjadi \texttt{tts-production-*} dan membuat network bernama \texttt{tts-production}. \texttt{project\_root} tetap dihitung dengan \texttt{abspath(...)} agar semua path build context dan mount dapat di-resolve secara stabil.

\begin{lstlisting}[language=terraform]
module "tts" {
  source       = "../modules/tts_stack"
  env          = "production"
  project_root = abspath("${path.module}/../../..")
}
\end{lstlisting}

Port production sengaja didedikasikan dan digeser lebih jauh (mis.\ gateway 28088) untuk memastikan tidak ada collision dengan dev/staging. Ini penting bila ketiga environment dijalankan paralel pada host yang sama (mis.\ untuk demo kelas atau uji banding performa).

\begin{lstlisting}[language=terraform]
ports = {
  redis         = 26379
  minio_api     = 29000
  minio_console = 29001
  api           = 28000
  web           = 28080
  gateway       = 28088
}
\end{lstlisting}

Nilai \texttt{mp3\_bucket} dan \texttt{internal\_token} diteruskan dari variabel root module agar environment production punya bucket terpisah (\texttt{tts-prod}) dan token yang berbeda dari environment lain.

\begin{lstlisting}[language=terraform]
mp3_bucket     = var.mp3_bucket
internal_token = var.internal_token
\end{lstlisting}

Berbeda dari dev/staging yang boleh eksplisit, production menegaskan praktik yang lebih aman: kredensial MinIO diambil dari variabel (bukan hardcode). Catatan ``DO NOT hardcode'' di sini adalah sinyal pedagogis bahwa pola hardcode hanya boleh untuk lab/demo.

\begin{lstlisting}[language=terraform]
minio_root_user     = var.minio_root_user
minio_root_password = var.minio_root_password
\end{lstlisting}

Konfigurasi Piper tetap menunjuk file config di \texttt{/models}. Karena \texttt{mount\_models} biasanya \texttt{false} pada production, maka file model dan config idealnya sudah termasuk di dalam image worker (atau dipasang lewat mekanisme deployment yang terkontrol, bukan mount host).

\begin{lstlisting}[language=terraform]
piper_model_config_path = "/models/en_GB-alan-medium.onnx.json"
piper_length_scale      = "1.0"
\end{lstlisting}

Concurrency production dinaikkan dengan meneruskan \texttt{worker\_replicas} (default 4). Ini akan membuat beberapa container worker paralel, yang semuanya menarik job dari Redis queue yang sama untuk environment \texttt{production}.

\begin{lstlisting}[language=terraform]
worker_replicas = var.worker_replicas
mount_models    = var.mount_models
\end{lstlisting}

Output \texttt{urls} meneruskan output modul untuk memudahkan akses endpoint. Namun untuk production sungguhan, Anda biasanya tidak mengekspose semuanya ke localhost, melainkan lewat reverse proxy/ingress yang lebih aman. Pada konteks lab ini, output tetap berguna untuk verifikasi cepat.

\begin{lstlisting}[language=terraform]
output "urls" {
  value = module.tts.urls
}
\end{lstlisting}

\subsubsection{\texttt{production.tfvars}: Nilai Konfigurasi untuk Production}

File \texttt{production.tfvars} menyimpan nilai variabel khusus production. Bucket dipisahkan menjadi \texttt{tts-prod} agar artefak MP3 tidak tercampur dengan environment lain. Token internal dibedakan dan dianggap rahasia. Pada contoh ini, user MinIO tetap default, dan password disebut ``sama dengan username'' (default MinIO) untuk kebutuhan demo, tetapi seharusnya diubah pada produksi nyata.

\begin{lstlisting}[language=terraform]
mp3_bucket     = "tts-prod"
internal_token = "changeme-production"

minio_root_user     = "minioadmin"
minio_root_password = "minioadmin" # ganti di produksi nyata

worker_replicas = 4
mount_models    = false
\end{lstlisting}

Konfigurasi ini menghasilkan empat worker paralel dan tidak melakukan mount model dari host. Ini cocok untuk skenario ``image-driven deploy'': model dibekukan bersama image untuk memastikan setiap worker memproses dengan versi model yang sama.

\subsubsection{Menjalankan Production (Untuk Lab/Demo)}

Perintah dijalankan dari folder \texttt{prod} dan menunjuk file var production.

\begin{lstlisting}[language=terraform]
# dijalankan dari iac/terraform/prod
terraform init
terraform apply -var-file=production.tfvars
\end{lstlisting}

Setelah \texttt{apply} selesai, gateway production dapat diakses melalui \texttt{http://localhost:28088}. Karena port sudah didedikasikan, production dapat berjalan bersamaan dengan dev (8088) dan staging (18088) pada host yang sama tanpa konflik.





\section{Terraform untuk Reproducibility dan Skalabilitas}

Terraform pada studi kasus TTS ini berperan sebagai fondasi \textit{Infrastructure as Code} (IaC) yang memastikan infrastruktur dapat direproduksi, diskalakan, dan dikontrol perubahannya secara terstruktur. Seluruh komponen—Redis, MinIO, API, Web, Gateway, dan Worker—didefinisikan dalam bentuk deklaratif sebagai \textit{desired state}, bukan sebagai rangkaian perintah manual.

Pendekatan ini mengubah infrastruktur dari konfigurasi ad-hoc menjadi artefak yang terdokumentasi, terversi, dan dapat diaudit.

\subsection*{Environment Parity}

Permasalahan umum dalam rekayasa perangkat lunak adalah ketidakkonsistenan antara environment development, staging, dan production. Perbedaan kecil pada port, jumlah replika, atau konfigurasi kredensial dapat menyebabkan perilaku sistem berbeda.

Dengan Terraform, arsitektur dasar tetap identik di semua environment karena modul yang sama digunakan ulang. Perbedaan hanya terletak pada nilai variabel.

Contoh konfigurasi yang berbeda antar environment:

\begin{lstlisting}[language=terraform]
# dev
worker_replicas = 1
mount_models    = false
gateway         = 8088
\end{lstlisting}

\begin{lstlisting}[language=terraform]
# staging
worker_replicas = 2
mount_models    = true
gateway         = 18088
\end{lstlisting}

\begin{lstlisting}[language=terraform]
# production
worker_replicas = 4
mount_models    = false
gateway         = 28088
\end{lstlisting}

Struktur infrastrukturnya tetap sama; hanya parameter konfigurasi yang berubah. Prinsip ini disebut \textit{environment parity}. Dengan parity ini, staging menjadi representasi arsitektur production dalam skala lebih kecil, sehingga potensi anomali lebih mudah dideteksi sebelum rilis produksi.

\subsection*{Infrastructure Provisioning Deklaratif}

Terraform menggunakan model deklaratif. Resource tidak dibuat melalui perintah imperatif seperti \texttt{docker run}, tetapi melalui deklarasi kondisi akhir yang diinginkan.

Contoh scaling worker secara deklaratif:

\begin{lstlisting}[language=terraform]
resource "docker_container" "worker" {
  count = var.worker_replicas
}
\end{lstlisting}

Jika nilai \texttt{worker\_replicas} berubah dari 2 menjadi 4, Terraform menghitung perbedaan (diff) antara state saat ini dan state yang diinginkan. Dua container tambahan akan direncanakan untuk dibuat.

Alur kerja umum:

\begin{lstlisting}[language=terraform]
terraform init
terraform plan  -var-file=production.tfvars
terraform apply -var-file=production.tfvars
\end{lstlisting}

Perintah \texttt{plan} menampilkan rencana perubahan sebelum eksekusi. Mekanisme ini memberikan transparansi terhadap dampak modifikasi konfigurasi.

\subsection*{Skalabilitas Horizontal yang Terkontrol}

Skalabilitas horizontal dicapai dengan mengubah satu variabel numerik:

\begin{lstlisting}[language=terraform]
variable "worker_replicas" {
  type    = number
  default = 1
}
\end{lstlisting}

Ketika nilai dinaikkan pada production menjadi 4, Terraform memastikan empat container worker aktif dalam network yang sama dan terhubung ke Redis queue yang identik. Arsitektur tidak berubah; hanya kapasitas yang meningkat.

Rollback juga bersifat deklaratif. Jika nilai replika dikurangi, Terraform akan menghapus container berlebih sesuai konfigurasi terbaru. Dengan demikian, scaling dan descaling dilakukan secara terkendali dan konsisten dengan state yang didefinisikan.

\subsection*{Kontrol Perubahan yang Terstruktur}

Terraform menyimpan state yang merepresentasikan infrastruktur aktual. Setiap perubahan pada file \texttt{.tf} atau \texttt{*.tfvars} menghasilkan rencana perubahan eksplisit.

Contoh perubahan port gateway:

\begin{lstlisting}[language=terraform]
gateway = 28088
# diubah menjadi
gateway = 38088
\end{lstlisting}

Terraform akan menampilkan bahwa container gateway perlu direcreate karena terjadi perubahan pada mapping port. Proses ini meningkatkan transparansi terhadap dampak konfigurasi.

Dalam praktik DevSecOps, file Terraform biasanya dikelola melalui version control (misalnya Git). Dengan demikian, perubahan infrastruktur:

Dapat direview melalui pull request,  
Dapat ditelusuri riwayatnya,  
Dapat dikaitkan dengan perubahan fitur atau isu tertentu.  

Infrastruktur menjadi bagian integral dari siklus hidup perangkat lunak.

\subsection*{Reproducibility sebagai Fondasi Eksperimen}

Reproducibility merupakan aspek penting dalam eksperimen performa dan pengujian sistem. Dengan Terraform, environment dapat dihancurkan dan dibangun ulang dengan konfigurasi yang identik.

\begin{lstlisting}[language=terraform]
terraform destroy -var-file=dev.tfvars
terraform apply   -var-file=dev.tfvars
\end{lstlisting}

Proses ini memastikan bahwa eksperimen seperti perbandingan 1 worker versus 4 worker dilakukan dalam kondisi yang konsisten. Tidak ada konfigurasi tersembunyi di luar kode.

Pendekatan ini juga mendukung otomatisasi CI/CD. Pipeline dapat:

Menginisialisasi environment sementara,  
Menjalankan integration test,  
Menghancurkan environment setelah pengujian selesai.  

Dengan demikian, reproducibility tidak hanya mendukung pembelajaran dan riset, tetapi juga praktik rekayasa perangkat lunak modern.

\subsection*{Kesimpulan Konseptual}

Terraform dalam arsitektur TTS berfungsi sebagai (1) Fondasi environment parity antar dev, staging, dan production,  
Mekanisme provisioning deklaratif untuk container, network, dan volume,  
(2) Alat scaling horizontal berbasis variabel,  
Sistem kontrol perubahan infrastruktur yang transparan dan dapat diaudit. (3) Landasan reproducibility untuk eksperimen dan CI/CD.  

Melalui pendekatan ini, infrastruktur menjadi terstruktur, terdokumentasi, dapat diuji, dan dapat direproduksi secara konsisten di berbagai environment.


\section{Kesimpulan}

Infrastructure as Code (IaC) menempatkan infrastruktur sebagai artefak yang didefinisikan secara deklaratif, terversi, dan dapat diaudit. Pada sistem modern yang tersusun dari banyak komponen—seperti Redis, MinIO, API, web frontend, worker, dan gateway—pendekatan manual cenderung menghasilkan inkonsistensi, \textit{environment drift}, serta konfigurasi yang sulit direproduksi. Melalui IaC, definisi infrastruktur menjadi \textit{single source of truth} yang memungkinkan penyusunan environment yang konsisten antar \texttt{dev}, \texttt{staging}, dan \texttt{production}, serta mendukung eksperimen terkontrol seperti perubahan jumlah worker, pergeseran port, dan pemisahan bucket penyimpanan.

Terraform menyediakan mekanisme yang sesuai untuk kebutuhan tersebut melalui konsep provider, resource, module, variable, output, dan state file. Kombinasi \texttt{plan}/\texttt{apply} memberikan kontrol perubahan yang terstruktur, sedangkan state memungkinkan deteksi drift dan perhitungan diff sebelum eksekusi. Di sisi lain, Docker Compose tetap relevan sebagai alat orkestrasi lokal yang cepat untuk prototyping dan pengembangan, terutama ketika fokusnya adalah menjalankan stack pada satu host. Dalam studi kasus TTS stack, Compose dapat berperan sebagai titik awal eksperimen, sementara Terraform mengangkat konfigurasi menuju praktik multi-environment yang reproducible, scalable, dan lebih dekat dengan kebutuhan production-ready; kedua alat tersebut saling melengkapi dalam evolusi sistem dari tahap pengembangan hingga tahap deployment yang lebih terkontrol.
