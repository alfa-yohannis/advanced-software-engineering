\chapter{Pendahuluan}

\section{Isi Mata Kuliah}

\subsection*{Sesi 1 --- Sistem Berjalan}
\textbf{Deskripsi:} Sesi ini memperkenalkan mahasiswa pada sebuah sistem perangkat lunak yang benar-benar berjalan, dengan tujuan agar seluruh abstraksi pada sesi berikutnya berangkat dari perilaku runtime yang konkret, sebelum konsep arsitektur atau pemodelan apa pun diperkenalkan.  
\textbf{Alat:} Docker.  
\textbf{Mahasiswa Non-IT:} Mahasiswa menjalankan aplikasi berbasis container, memodifikasi parameter lingkungan, serta mengamati perubahan perilaku sistem, sambil menjelaskan kegagalan dan efek konfigurasi menggunakan bahasa alami.  
\textbf{Mahasiswa IT:} Mahasiswa membangun dan menjalankan container, mengatur port dan environment variable, serta mendiagnosis kegagalan runtime langsung pada level container.

\subsection*{Sesi 2 --- Observabilitas}
\textbf{Deskripsi:} Mahasiswa belajar mengamati perilaku sistem sebelum menalar struktur atau desain, dengan menjadikan data runtime sebagai sumber utama pemahaman sistem.  
\textbf{Alat:} Prometheus, Grafana, dan konsep OpenTelemetry.  
\textbf{Mahasiswa Non-IT:} Mahasiswa menafsirkan dashboard, metrik, dan log, serta mengaitkan nilai yang diamati dengan perilaku yang terlihat oleh pengguna dan kegagalan sistem.  
\textbf{Mahasiswa IT:} Mahasiswa mengonfigurasi telemetri dasar, memvisualisasikan log dan trace, serta mengaitkan data observabilitas dengan peristiwa runtime.

\subsection*{Sesi 3 --- Keamanan Sistem Perangkat Lunak}
\textbf{Deskripsi:} Keamanan dan kepatuhan diperkenalkan sebagai mekanisme yang secara aktif membatasi perilaku runtime sistem, bukan sekadar sebagai aktivitas audit eksternal.  
\textbf{Alat:} Docker, Python, Docker Compose.  
\textbf{Mahasiswa Non-IT:} Mahasiswa mengidentifikasi aturan keamanan, batasan, serta pelanggaran kebijakan, dan menjelaskan dampaknya terhadap risiko dan kepatuhan sistem.  
\textbf{Mahasiswa IT:} Mahasiswa menerapkan kontrol keamanan dasar pada container dan deployment, serta mengonfigurasi batasan runtime pada level lingkungan.

\subsection*{Sesi 4 --- CI/CD dan Otomasi Terstruktur}

\textbf{Deskripsi:} Mahasiswa mempelajari penerapan \textit{continuous integration} dan \textit{continuous deployment} sebagai bentuk otomasi terstruktur dalam pengembangan perangkat lunak. Melalui pipeline CI/CD, mahasiswa mengamati bagaimana proses build, pengujian, dan deployment dapat dijalankan secara konsisten, terverifikasi, dan dapat direproduksi tanpa bergantung pada langkah manual.
\textbf{Alat:} CI/CD berbasis YAML (GitHub Actions), Bash, Docker, dan Docker Compose.
\textbf{Mahasiswa Non-IT:} Mahasiswa menelusuri alur eksekusi pipeline CI/CD, memahami tujuan setiap tahap (checkout, testing, deployment), serta mendokumentasikan peran otomasi dalam menjaga konsistensi dan kualitas sistem.
\textbf{Mahasiswa IT:} Mahasiswa mengonfigurasi dan memodifikasi pipeline CI/CD lintas lingkungan (CI dan deployment), menjalankan pengujian otomatis, serta menganalisis dampak perubahan konfigurasi terhadap keberhasilan pipeline dan stabilitas sistem runtime.


\subsection*{Sesi 5 --- Model Runtime dan Perilaku Eksekutabel}
\textbf{Deskripsi:} Artefak runtime dieksplisitkan sebagai model dan langsung diperlakukan sebagai struktur keputusan yang dapat dieksekusi, menjembatani transisi dari konfigurasi implisit ke eksekusi yang terkendali.  
\textbf{Alat:} Pemodelan konseptual, representasi YAML atau JSON, serta interpreter Python sederhana.  
\textbf{Mahasiswa Non-IT:} Mahasiswa mengidentifikasi struktur runtime sebagai model dan menjelaskan bagaimana eksekusi mengikuti keputusan dalam model secara bertahap.  
\textbf{Mahasiswa IT:} Mahasiswa mengeksternalisasi keputusan runtime ke dalam model eksplisit dan mengimplementasikan interpreter dasar untuk mengeksekusi model tersebut.

\subsection*{Sesi 6 --- Dasar-Dasar Metamodeling}
\textbf{Deskripsi:} Mahasiswa mendefinisikan struktur model yang valid dengan memperkenalkan metamodel sebagai sistem tipe yang memformalkan perhatian runtime dan batas eksekusi.  
\textbf{Alat:} EMF dan Ecore.  
\textbf{Mahasiswa Non-IT:} Mahasiswa menafsirkan diagram metamodel dan menalar apakah contoh model bersifat valid atau tidak valid.  
\textbf{Mahasiswa IT:} Mahasiswa merancang metamodel Ecore yang secara formal menangkap konsep runtime, pipeline, dan kebijakan.

\subsection*{Sesi 7 --- Rekayasa DSL Tekstual}
\textbf{Deskripsi:} Sebuah domain-specific language (DSL) tekstual direkayasa untuk menggantikan praktik konfigurasi dan skrip yang terfragmentasi dengan sintaks konkret yang koheren.  
\textbf{Alat:} Xtext.  
\textbf{Mahasiswa Non-IT:} Mahasiswa membaca dan menulis contoh DSL serta mengevaluasi sejauh mana bahasa tersebut mengekspresikan maksud domain dengan jelas.  
\textbf{Mahasiswa IT:} Mahasiswa merancang grammar, mengimplementasikan parsing, serta mendefinisikan aturan scoping dan linking.

\subsection*{Sesi 8 --- Rekayasa Bahasa Visual untuk Model Runtime}
\textbf{Deskripsi:} Bahasa visual diperkenalkan sebagai sintaks konkret yang dapat dieksekusi di atas sintaks abstrak yang sama, dengan penekanan pada pengeditan dan validasi model, bukan sekadar dokumentasi.  
\textbf{Alat:} Sirius atau Papyrus.  
\textbf{Mahasiswa Non-IT:} Mahasiswa mengeksplorasi, mengedit, dan memvalidasi model runtime menggunakan editor visual untuk menalar struktur dan batasan.  
\textbf{Mahasiswa IT:} Mahasiswa mendefinisikan viewpoint visual, mapping, dan constraint yang mengaitkan elemen metamodel dengan representasi visual yang dapat dieksekusi.

\subsection*{Sesi 9 --- Rekayasa Bahasa Proyeksional}
\textbf{Deskripsi:} Rekayasa bahasa proyeksional diperkenalkan untuk menunjukkan komposisi dan evolusi bahasa yang sadar struktur tanpa keterbatasan parsing.  
\textbf{Alat:} JetBrains MPS.  
\textbf{Mahasiswa Non-IT:} Mahasiswa membandingkan bahasa tekstual, visual, dan proyeksional, serta memperluas bahasa menggunakan editor terstruktur.  
\textbf{Mahasiswa IT:} Mahasiswa mengimplementasikan konstruksi bahasa proyeksional dan mengomposisikan beberapa DSL menjadi satu bahasa terpadu.

\subsection*{Sesi 10 --- Desain Semantik Model Eksekutabel}
\textbf{Deskripsi:} Model diberikan makna operasional yang presisi dengan mendefinisikan bagaimana elemen model berperilaku saat dieksekusi, serta membedakan antara interpretasi dan generasi.  
\textbf{Alat:} Java, Kotlin, atau Python.  
\textbf{Mahasiswa Non-IT:} Mahasiswa menjelaskan semantik eksekusi menggunakan skenario runtime konkret dan penalaran terstruktur.  
\textbf{Mahasiswa IT:} Mahasiswa mengimplementasikan interpreter atau mesin semantik yang mengeksekusi model secara langsung.

\subsection*{Sesi 11 --- Transformasi Model ke Model dan Refinement}
\textbf{Deskripsi:} Model ditransformasikan dan diperkaya secara sistematis untuk mendukung pengelolaan abstraksi, variabilitas, dan spesialisasi lingkungan, sambil tetap menjaga semantik model.  
\textbf{Alat:} Epsilon ETL atau alat transformasi model-ke-model yang setara.  
\textbf{Mahasiswa Non-IT:} Mahasiswa menalar bagaimana model berevolusi lintas tingkat abstraksi menggunakan contoh-contoh konkret.  
\textbf{Mahasiswa IT:} Mahasiswa mengimplementasikan transformasi model-ke-model yang memperkaya model abstrak menjadi varian yang siap dieksekusi.

\subsection*{Sesi 12 --- Constraint dan Validasi Model}
\textbf{Deskripsi:} Constraint terkait kebenaran, keselamatan, dan keamanan diterapkan pada model sejak tahap desain untuk mencegah konfigurasi runtime yang tidak valid atau berbahaya.  
\textbf{Alat:} OCL terintegrasi dengan model berbasis EMF.  
\textbf{Mahasiswa Non-IT:} Mahasiswa merumuskan aturan kebenaran dan kepatuhan serta mengidentifikasi skenario model yang tidak valid.  
\textbf{Mahasiswa IT:} Mahasiswa mengimplementasikan constraint OCL dan mengintegrasikan validasi ke dalam alur kerja pemodelan.

\subsection*{Sesi 13 --- Generasi Model ke Teks dan Eksekusi DevSecOps}
\textbf{Deskripsi:} Model yang telah tervalidasi diterjemahkan menjadi artefak yang dapat dieksekusi, menutup siklus antara pemodelan dan eksekusi DevSecOps otomatis.  
\textbf{Alat:} Epsilon EGL, generator Xtext atau MPS, dengan target pipeline CI/CD, Kubernetes, dan Terraform.  
\textbf{Mahasiswa Non-IT:} Mahasiswa menelusuri bagaimana model tervalidasi diubah menjadi artefak runtime dan menalar keterlacakan serta kebenarannya.  
\textbf{Mahasiswa IT:} Mahasiswa mengimplementasikan generator model-ke-teks dan mengintegrasikan artefak hasil generasi ke dalam pipeline eksekusi otomatis.


\section{Tugas Mata Kuliah: Pilihan 1}

Tugas mata kuliah ini dirancang dalam bentuk studi kasus pemodelan sistem nyata yang berasal dari lingkungan kerja mahasiswa. Sistem yang dikaji, selanjutnya disebut sebagai \textit{Sistem X}, dapat berupa sistem manual, sistem berbasis teknologi informasi, maupun kombinasi keduanya. Tujuan utama tugas ini bukanlah implementasi teknis, melainkan pengembangan kemampuan mahasiswa dalam memahami, memodelkan, dan menalar perilaku sistem berdasarkan observasi runtime. Integrasikan teknologi-teknologi terbaru, seperti 3D printers, Artificial Intelligence, Business Intelligence, Information Systems, Internet of Things, Sensors, DevOps, atau teknologi lama yang dapat meningkatkan kualitas sistem tersebut (lebih murah, lebih cepat, lebih akurat, mempunyai kemampuan baru, dsb).

\subsection{Deskripsi Tugas}

Mahasiswa diminta untuk mengidentifikasi sebuah proses bisnis nyata (manual, menggunakan teknologi, atau kombinasi keduanya) yang dijalankan di kantor atau unit kerja tempat mahasiswa bekerja. Proses tersebut kemudian dianalisis dengan langkah-langkah berikut:

\begin{itemize}
    \item Mengidentifikasi aktor (manusia atau non-manusia yang memiliki peran tertentu) yang terlibat (manusia dan/atau sistem).
    \item Mendeskripsikan interaksi antar aktor beserta aliran pesan atau data yang dipertukarkan.	
    \item Mengklasifikasikan elemen proses yang bersifat tetap (invariant), berulang, dan bervariasi.
	\item MEngidentifikasi aktivitas manual yang dapat di-otomasi dan tidak dapat di-otomasi.
	\item Mengamati perilaku sistem dalam kondisi normal maupun ketika terjadi gangguan, keterlambatan, atau pengecualian, elemen-elemen mana yang sering bermasalah dan bagaimana solusinya.
    \item Menyusun model \textit{AS-IS} yang merepresentasikan kondisi sistem saat ini.
    \item Mengusulkan model \textit{TO-BE} yang memperkenalkan element baru, penghapusan elemen lama, penggantian, atau tingkat otomatisasi yang lebih tinggi dengan tetap mempertimbangkan batasan operasional, risiko, dan tanggung jawab manusia.
	\item Evaluasi kedua model \textit{AS-IS} dan \textit{TO-BE} dengan menggunakan metode di bawah.
\end{itemize}

Model yang dihasilkan tidak ditujukan sebagai dokumentasi statis, melainkan sebagai artefak analitis untuk menjelaskan perilaku runtime Sistem X serta mendukung penalaran terhadap perubahan dan keputusan otomasi.

\subsection{Research Questions}

Tugas ini diarahkan untuk menjawab dua \textit{research questions} berikut:

\begin{enumerate}
    \item \textbf{RQ1:} 
    Sejauh mana model perilaku runtime Sistem X yang disusun berdasarkan observasi lapangan memenuhi kriteria kelengkapan, konsistensi, dan keterlacakan terhadap kondisi nyata?

    \item \textbf{RQ2:} 
    Apakah penggunaan model runtime yang eksplisit menghasilkan peningkatan kualitas penalaran terhadap kegagalan, risiko, dan dampak perubahan pada Sistem X dibandingkan dengan deskripsi informal?
\end{enumerate}

Kedua pertanyaan penelitian ini berfokus pada kualitas model yang dihasilkan serta dampaknya terhadap kemampuan penalaran mahasiswa, tanpa mensyaratkan keahlian pemrograman atau implementasi teknis.

\subsection{Metode Evaluasi}

Untuk menjawab kedua \textit{research questions} tersebut, digunakan dua metode evaluasi yang bersifat sederhana, terstruktur, dan dapat direplikasi. Keduanya membutuhkan responden pakar paling sedikit 5 orang.

\subsubsection{Evaluasi Kualitas Model (RQ1)}

Evaluasi terhadap RQ1 dilakukan menggunakan rubrik penilaian kualitas model. Setiap model \textit{AS-IS} dan \textit{TO-BE} dinilai berdasarkan beberapa kriteria berikut:

\begin{itemize}
    \item \textit{Completeness}: sejauh mana seluruh aktor dan aktivitas utama Sistem X direpresentasikan.
    \item \textit{Consistency}: tidak adanya kontradiksi logis dalam alur proses.
    \item \textit{Traceability}: keterlacakan elemen model terhadap hasil observasi nyata.
    \item \textit{Clarity of variability}: kejelasan pembedaan antara elemen tetap dan elemen variabel.
    \item \textit{Automation rationale}: kejelasan alasan di balik keputusan manual, semi-otomatis, atau otomatis.
\end{itemize}

Cari referensi yang menyebutkan bahwa kelima dimensi tersebut adalah penting. Setiap kriteria dinilai menggunakan skala ordinal (misalnya 1--5), disertai catatan kualitatif untuk menjelaskan kekuatan dan kelemahan model.

\subsubsection{Evaluasi Dukungan Penalaran Berbasis Model (RQ2)}

Evaluasi terhadap RQ2 dilakukan melalui analisis komparatif terhadap artefak model \textit{AS-IS} dan \textit{TO-BE} Sistem X. Evaluasi ini bertujuan untuk menilai sejauh mana masing-masing model menyediakan struktur dan informasi yang memadai untuk mendukung penalaran yang sistematis terhadap kegagalan, risiko, dan dampak perubahan sistem, dibandingkan dengan deskripsi informal proses.

Penilaian dilakukan dengan menganalisis kemampuan masing-masing representasi dalam menjawab sejumlah pertanyaan analitis yang difokuskan pada karakteristik artefak model, antara lain:
\begin{enumerate}
    \item Deskripsikan tujuan sistem dan apa yang dilakukan oleh masing-masing model! Dan apa yang membedakan keduanya?
    \item Masalah apa yang yang kemungkinan besar dapat terjadi pada masing-masing model? Seberapa krusial masalah tersebut?
    \item Model mana yang menurut Anda lebih baik dalam mencapai tujuan? Mengapa? (pertimbangkan dari berbagai sisi, misalnya biaya, kecepatan, kapasitas, kelengkapan, dsb.)
\end{enumerate}

Model \textit{AS-IS}, model \textit{TO-BE}, dan deskripsi informal dibandingkan secara kualitatif berdasarkan tingkat eksplisitasi perilaku, kejelasan hubungan antar elemen, dan konsistensi representasi analitis. Hasil perbandingan ini digunakan untuk menilai sejauh mana model runtime yang eksplisit memberikan dukungan penalaran yang lebih kuat dibandingkan pendekatan deskriptif.

\subsection{Struktur Makalah IEEE}

Hasil tugas ini disusun dalam bentuk makalah ilmiah dengan struktur standar IEEE conference sebagai berikut:

\begin{itemize}
    \item \textbf{Introduction}: latar belakang masalah dan motivasi penelitian.
    \item \textbf{Background and Related Work}: ringkasan singkat konsep pemodelan proses dan sistem sosio-teknis.
    \item \textbf{Case Study Description}: deskripsi Sistem X dan konteks operasionalnya.
    \item \textbf{Modeling Approach}: metode observasi dan konstruksi model \textit{AS-IS} dan \textit{TO-BE}.
    \item \textbf{Evaluation}: penjelasan metode evaluasi dan hasil yang diperoleh.
    \item \textbf{Discussion}: interpretasi hasil, implikasi, dan keterbatasan.
    \item \textbf{Threats to Validity}: potensi bias dan keterbatasan metodologis.
    \item \textbf{Conclusion and Future Work}: kesimpulan dan arah pengembangan selanjutnya.
\end{itemize}

Struktur ini memastikan bahwa hasil tugas mahasiswa tidak hanya bernilai pedagogis, tetapi juga memenuhi standar pelaporan ilmiah untuk publikasi pada konferensi IEEE tingkat regional.


\section{Tugas Mata Kuliah: Pilihan 2}

Tugas ini berupa studi komparasi dua perangkat lunak, library, atau format data yang digunakan untuk tujuan serupa. Studi dilakukan melalui eksperimen performa yang dapat dijalankan pada satu komputer tanpa melibatkan responden manusia. Evaluasi difokuskan pada pengukuran waktu eksekusi, penggunaan memori, ukuran data, dan throughput, dengan konfigurasi eksperimen yang terkontrol dan dapat direplikasi.

Tujuan studi bukan untuk mengklaim keunggulan universal suatu teknologi, melainkan untuk mengamati dan melaporkan perilaku performa pada konteks beban kerja tertentu yang jarang dibahas secara eksplisit dalam literatur.

Contoh topik studi komparasi yang dapat dilakukan secara mandiri dan berpotensi memberikan kebaruan penelitian antara lain:
\begin{enumerate}
    \item Perbandingan format JSON dan MessagePack untuk komunikasi data berukuran besar, dengan pengukuran waktu serialisasi, deserialisasi, ukuran payload, dan penggunaan memori.
    \item Perbandingan format CSV dan Parquet untuk analisis data tabular berulang, dengan fokus pada waktu baca/tulis, ukuran berkas, dan konsumsi memori.
    \item Perbandingan SQLite dan PostgreSQL untuk beban kerja analitik ringan hingga menengah pada satu mesin, dengan pengukuran waktu kueri agregasi dan penggunaan memori.
    \item Perbandingan REST API berbasis JSON dan REST API dengan payload biner (misalnya MessagePack) terhadap latensi dan ukuran data yang ditransmisikan.
    \item Perbandingan OpenCV dan Pillow untuk operasi pemrosesan citra sederhana (misalnya \textit{resize} dan \textit{encoding}), dengan pengukuran waktu proses dan konsumsi memori.
    \item Perbandingan algoritma kompresi \texttt{gzip} dan \texttt{zstd} untuk berkas log, dengan pengukuran waktu kompresi, dekompresi, dan rasio kompresi.
	\item PostgreSQLvs MongoDB dalam hal penyimpanan gambar atau gambar time-series.
\end{enumerate}

\cite{020practical}.