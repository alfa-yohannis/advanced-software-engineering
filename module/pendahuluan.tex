\chapter{Pendahuluan}

\section{Isi Mata Kuliah}

\subsection*{Sesi 1 --- Sistem Berjalan}
\textbf{Deskripsi:} Sesi ini memperkenalkan mahasiswa pada sebuah sistem perangkat lunak yang benar-benar berjalan, dengan tujuan agar seluruh abstraksi pada sesi berikutnya berangkat dari perilaku runtime yang konkret, sebelum konsep arsitektur atau pemodelan apa pun diperkenalkan.  
\textbf{Alat:} Docker.  
\textbf{Mahasiswa Non-IT:} Mahasiswa menjalankan aplikasi berbasis container, memodifikasi parameter lingkungan, serta mengamati perubahan perilaku sistem, sambil menjelaskan kegagalan dan efek konfigurasi menggunakan bahasa alami.  
\textbf{Mahasiswa IT:} Mahasiswa membangun dan menjalankan container, mengatur port dan environment variable, serta mendiagnosis kegagalan runtime langsung pada level container.

\subsection*{Sesi 2 --- Observabilitas}
\textbf{Deskripsi:} Mahasiswa belajar mengamati perilaku sistem sebelum menalar struktur atau desain, dengan menjadikan data runtime sebagai sumber utama pemahaman sistem.  
\textbf{Alat:} Prometheus, Grafana, dan konsep OpenTelemetry.  
\textbf{Mahasiswa Non-IT:} Mahasiswa menafsirkan dashboard, metrik, dan log, serta mengaitkan nilai yang diamati dengan perilaku yang terlihat oleh pengguna dan kegagalan sistem.  
\textbf{Mahasiswa IT:} Mahasiswa mengonfigurasi telemetri dasar, memvisualisasikan log dan trace, serta mengaitkan data observabilitas dengan peristiwa runtime.

\subsection*{Sesi 3 --- Kontrol Runtime, Keamanan, dan Kebijakan}
\textbf{Deskripsi:} Keamanan dan kepatuhan diperkenalkan sebagai mekanisme yang secara aktif membatasi perilaku runtime sistem, bukan sekadar sebagai aktivitas audit eksternal.  
\textbf{Alat:} Docker, pengantar konsep Kubernetes, dan konsep Terraform.  
\textbf{Mahasiswa Non-IT:} Mahasiswa mengidentifikasi aturan keamanan, batasan, serta pelanggaran kebijakan, dan menjelaskan dampaknya terhadap risiko dan kepatuhan sistem.  
\textbf{Mahasiswa IT:} Mahasiswa menerapkan kontrol keamanan dasar pada container dan deployment, serta mengonfigurasi batasan runtime pada level lingkungan.

\subsection*{Sesi 4 --- CI/CD dan Ledakan Skrip}
\textbf{Deskripsi:} Mahasiswa mengalami langsung keterbatasan otomasi berbasis skrip melalui pipeline continuous integration dan deployment, dengan menyoroti duplikasi dan kerapuhan solusi skrip.  
\textbf{Alat:} CI/CD berbasis YAML dan Bash.  
\textbf{Mahasiswa Non-IT:} Mahasiswa menelusuri langkah eksekusi pipeline dan mendokumentasikan masalah pemeliharaan otomasi.  
\textbf{Mahasiswa IT:} Mahasiswa memodifikasi pipeline CI/CD lintas lingkungan dan mengamati bagaimana perubahan kecil pada skrip dapat memicu kegagalan runtime.

\subsection*{Sesi 5 --- Model Runtime dan Perilaku Eksekutabel}
\textbf{Deskripsi:} Artefak runtime dieksplisitkan sebagai model dan langsung diperlakukan sebagai struktur keputusan yang dapat dieksekusi, menjembatani transisi dari konfigurasi implisit ke eksekusi yang terkendali.  
\textbf{Alat:} Pemodelan konseptual, representasi YAML atau JSON, serta interpreter Python sederhana.  
\textbf{Mahasiswa Non-IT:} Mahasiswa mengidentifikasi struktur runtime sebagai model dan menjelaskan bagaimana eksekusi mengikuti keputusan dalam model secara bertahap.  
\textbf{Mahasiswa IT:} Mahasiswa mengeksternalisasi keputusan runtime ke dalam model eksplisit dan mengimplementasikan interpreter dasar untuk mengeksekusi model tersebut.

\subsection*{Sesi 6 --- Dasar-Dasar Metamodeling}
\textbf{Deskripsi:} Mahasiswa mendefinisikan struktur model yang valid dengan memperkenalkan metamodel sebagai sistem tipe yang memformalkan perhatian runtime dan batas eksekusi.  
\textbf{Alat:} EMF dan Ecore.  
\textbf{Mahasiswa Non-IT:} Mahasiswa menafsirkan diagram metamodel dan menalar apakah contoh model bersifat valid atau tidak valid.  
\textbf{Mahasiswa IT:} Mahasiswa merancang metamodel Ecore yang secara formal menangkap konsep runtime, pipeline, dan kebijakan.

\subsection*{Sesi 7 --- Rekayasa DSL Tekstual}
\textbf{Deskripsi:} Sebuah domain-specific language (DSL) tekstual direkayasa untuk menggantikan praktik konfigurasi dan skrip yang terfragmentasi dengan sintaks konkret yang koheren.  
\textbf{Alat:} Xtext.  
\textbf{Mahasiswa Non-IT:} Mahasiswa membaca dan menulis contoh DSL serta mengevaluasi sejauh mana bahasa tersebut mengekspresikan maksud domain dengan jelas.  
\textbf{Mahasiswa IT:} Mahasiswa merancang grammar, mengimplementasikan parsing, serta mendefinisikan aturan scoping dan linking.

\subsection*{Sesi 8 --- Rekayasa Bahasa Visual untuk Model Runtime}
\textbf{Deskripsi:} Bahasa visual diperkenalkan sebagai sintaks konkret yang dapat dieksekusi di atas sintaks abstrak yang sama, dengan penekanan pada pengeditan dan validasi model, bukan sekadar dokumentasi.  
\textbf{Alat:} Sirius atau Papyrus.  
\textbf{Mahasiswa Non-IT:} Mahasiswa mengeksplorasi, mengedit, dan memvalidasi model runtime menggunakan editor visual untuk menalar struktur dan batasan.  
\textbf{Mahasiswa IT:} Mahasiswa mendefinisikan viewpoint visual, mapping, dan constraint yang mengaitkan elemen metamodel dengan representasi visual yang dapat dieksekusi.

\subsection*{Sesi 9 --- Rekayasa Bahasa Proyeksional}
\textbf{Deskripsi:} Rekayasa bahasa proyeksional diperkenalkan untuk menunjukkan komposisi dan evolusi bahasa yang sadar struktur tanpa keterbatasan parsing.  
\textbf{Alat:} JetBrains MPS.  
\textbf{Mahasiswa Non-IT:} Mahasiswa membandingkan bahasa tekstual, visual, dan proyeksional, serta memperluas bahasa menggunakan editor terstruktur.  
\textbf{Mahasiswa IT:} Mahasiswa mengimplementasikan konstruksi bahasa proyeksional dan mengomposisikan beberapa DSL menjadi satu bahasa terpadu.

\subsection*{Sesi 10 --- Desain Semantik Model Eksekutabel}
\textbf{Deskripsi:} Model diberikan makna operasional yang presisi dengan mendefinisikan bagaimana elemen model berperilaku saat dieksekusi, serta membedakan antara interpretasi dan generasi.  
\textbf{Alat:} Java, Kotlin, atau Python.  
\textbf{Mahasiswa Non-IT:} Mahasiswa menjelaskan semantik eksekusi menggunakan skenario runtime konkret dan penalaran terstruktur.  
\textbf{Mahasiswa IT:} Mahasiswa mengimplementasikan interpreter atau mesin semantik yang mengeksekusi model secara langsung.

\subsection*{Sesi 11 --- Transformasi Model ke Model dan Refinement}
\textbf{Deskripsi:} Model ditransformasikan dan diperkaya secara sistematis untuk mendukung pengelolaan abstraksi, variabilitas, dan spesialisasi lingkungan, sambil tetap menjaga semantik model.  
\textbf{Alat:} Epsilon ETL atau alat transformasi model-ke-model yang setara.  
\textbf{Mahasiswa Non-IT:} Mahasiswa menalar bagaimana model berevolusi lintas tingkat abstraksi menggunakan contoh-contoh konkret.  
\textbf{Mahasiswa IT:} Mahasiswa mengimplementasikan transformasi model-ke-model yang memperkaya model abstrak menjadi varian yang siap dieksekusi.

\subsection*{Sesi 12 --- Constraint dan Validasi Model}
\textbf{Deskripsi:} Constraint terkait kebenaran, keselamatan, dan keamanan diterapkan pada model sejak tahap desain untuk mencegah konfigurasi runtime yang tidak valid atau berbahaya.  
\textbf{Alat:} OCL terintegrasi dengan model berbasis EMF.  
\textbf{Mahasiswa Non-IT:} Mahasiswa merumuskan aturan kebenaran dan kepatuhan serta mengidentifikasi skenario model yang tidak valid.  
\textbf{Mahasiswa IT:} Mahasiswa mengimplementasikan constraint OCL dan mengintegrasikan validasi ke dalam alur kerja pemodelan.

\subsection*{Sesi 13 --- Generasi Model ke Teks dan Eksekusi DevSecOps}
\textbf{Deskripsi:} Model yang telah tervalidasi diterjemahkan menjadi artefak yang dapat dieksekusi, menutup siklus antara pemodelan dan eksekusi DevSecOps otomatis.  
\textbf{Alat:} Epsilon EGL, generator Xtext atau MPS, dengan target pipeline CI/CD, Kubernetes, dan Terraform.  
\textbf{Mahasiswa Non-IT:} Mahasiswa menelusuri bagaimana model tervalidasi diubah menjadi artefak runtime dan menalar keterlacakan serta kebenarannya.  
\textbf{Mahasiswa IT:} Mahasiswa mengimplementasikan generator model-ke-teks dan mengintegrasikan artefak hasil generasi ke dalam pipeline eksekusi otomatis.
